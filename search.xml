<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[v-tooltip 使用中文文档]]></title>
    <url>%2F%E6%8F%92%E4%BB%B6%E5%B7%A5%E5%85%B7%2Fv-tooltip%20%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[[TOC] 一、开始使用 v-tooltiphttps://github.com/Akryum/v-tooltip （一）Node 环境npm i -save v-tooltip 安装依赖 1 全局注册插件1234import Vue from 'vue'import VTooltip from 'v-tooltip'Vue.use(VTooltip) 2 解构引入组件和指令除了全部引入还可以解构出组件或者指令分别引入 123456import Vue from 'vue'import &#123; VTooltip, VPopover, VClosePopover &#125; from 'v-tooltip'Vue.directive('tooltip', VTooltip)Vue.directive('close-popover', VClosePopover)Vue.component('v-popover', VPopover) （二）浏览器环境CDN 引入插件 &lt;script src=&quot;https://unpkg.com/v-tooltip&quot;&gt;&lt;/script&gt; 如果在该页面被检测到有 vue ，那么该插件会自动注册。如果没有反应，可以手动注册 1234567// 手动注册Vue.use(VTooltip)// 或者按需注册Vue.directive('tooltip', VTooltip.VTooltip)Vue.directive('close-popover', VTooltip.VClosePopover)Vue.component('v-popover', VTooltip.VPopover) （三）样式选择是两种CSS编译器的样式示例。 举例了主要的几个样式类，如 tooltip-inner，就是弹出的主内容区 1 Sass / Less123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109.tooltip &#123; display: block !important; z-index: 10000; .tooltip-inner &#123; background: black; color: white; border-radius: 16px; padding: 5px 10px 4px; &#125; .tooltip-arrow &#123; width: 0; height: 0; border-style: solid; position: absolute; margin: 5px; border-color: black; z-index: 1; &#125; &amp;[x-placement^="top"] &#123; margin-bottom: 5px; .tooltip-arrow &#123; border-width: 5px 5px 0 5px; border-left-color: transparent !important; border-right-color: transparent !important; border-bottom-color: transparent !important; bottom: -5px; left: calc(50% - 5px); margin-top: 0; margin-bottom: 0; &#125; &#125; &amp;[x-placement^="bottom"] &#123; margin-top: 5px; .tooltip-arrow &#123; border-width: 0 5px 5px 5px; border-left-color: transparent !important; border-right-color: transparent !important; border-top-color: transparent !important; top: -5px; left: calc(50% - 5px); margin-top: 0; margin-bottom: 0; &#125; &#125; &amp;[x-placement^="right"] &#123; margin-left: 5px; .tooltip-arrow &#123; border-width: 5px 5px 5px 0; border-left-color: transparent !important; border-top-color: transparent !important; border-bottom-color: transparent !important; left: -5px; top: calc(50% - 5px); margin-left: 0; margin-right: 0; &#125; &#125; &amp;[x-placement^="left"] &#123; margin-right: 5px; .tooltip-arrow &#123; border-width: 5px 0 5px 5px; border-top-color: transparent !important; border-right-color: transparent !important; border-bottom-color: transparent !important; right: -5px; top: calc(50% - 5px); margin-left: 0; margin-right: 0; &#125; &#125; &amp;.popover &#123; $color: #f9f9f9; .popover-inner &#123; background: $color; color: black; padding: 24px; border-radius: 5px; box-shadow: 0 5px 30px rgba(black, .1); &#125; .popover-arrow &#123; border-color: $color; &#125; &#125; &amp;[aria-hidden='true'] &#123; visibility: hidden; opacity: 0; transition: opacity .15s, visibility .15s; &#125; &amp;[aria-hidden='false'] &#123; visibility: visible; opacity: 1; transition: opacity .15s; &#125;&#125; 2 CSS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105.tooltip &#123; display: block !important; z-index: 10000;&#125;.tooltip .tooltip-inner &#123; background: black; color: white; border-radius: 16px; padding: 5px 10px 4px;&#125;.tooltip .tooltip-arrow &#123; width: 0; height: 0; border-style: solid; position: absolute; margin: 5px; border-color: black; z-index: 1;&#125;.tooltip[x-placement^="top"] &#123; margin-bottom: 5px;&#125;.tooltip[x-placement^="top"] .tooltip-arrow &#123; border-width: 5px 5px 0 5px; border-left-color: transparent !important; border-right-color: transparent !important; border-bottom-color: transparent !important; bottom: -5px; left: calc(50% - 5px); margin-top: 0; margin-bottom: 0;&#125;.tooltip[x-placement^="bottom"] &#123; margin-top: 5px;&#125;.tooltip[x-placement^="bottom"] .tooltip-arrow &#123; border-width: 0 5px 5px 5px; border-left-color: transparent !important; border-right-color: transparent !important; border-top-color: transparent !important; top: -5px; left: calc(50% - 5px); margin-top: 0; margin-bottom: 0;&#125;.tooltip[x-placement^="right"] &#123; margin-left: 5px;&#125;.tooltip[x-placement^="right"] .tooltip-arrow &#123; border-width: 5px 5px 5px 0; border-left-color: transparent !important; border-top-color: transparent !important; border-bottom-color: transparent !important; left: -5px; top: calc(50% - 5px); margin-left: 0; margin-right: 0;&#125;.tooltip[x-placement^="left"] &#123; margin-right: 5px;&#125;.tooltip[x-placement^="left"] .tooltip-arrow &#123; border-width: 5px 0 5px 5px; border-top-color: transparent !important; border-right-color: transparent !important; border-bottom-color: transparent !important; right: -5px; top: calc(50% - 5px); margin-left: 0; margin-right: 0;&#125;.tooltip.popover .popover-inner &#123; background: #f9f9f9; color: black; padding: 24px; border-radius: 5px; box-shadow: 0 5px 30px rgba(black, .1);&#125;.tooltip.popover .popover-arrow &#123; border-color: #f9f9f9;&#125;.tooltip[aria-hidden='true'] &#123; visibility: hidden; opacity: 0; transition: opacity .15s, visibility .15s;&#125;.tooltip[aria-hidden='false'] &#123; visibility: visible; opacity: 1; transition: opacity .15s;&#125; 二、用法指令与组件的使用区别：指令通过配置对象来实现定制，组件通过元素属性来实现定制。 本质上是一样的。 （一）指令方式1 基本使用方式1）在 template 模板中同时支持静态字符串或者是响应式属性 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;button v-tooltip=&quot;&apos;You have 2 new messages.&apos;&quot;&gt;&lt;/button&gt; &lt;button v-tooltip=&quot;msg&quot;&gt;&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; msg:&apos;tooltip&apos; &#125; &#125;&#125;&lt;/script&gt; 2）修饰符列表用修饰符来指定方位 &lt;button v-tooltip.bottom-start=&quot;&#39;xxxxx&#39;&quot;&gt; 还有其他： &#39;auto&#39; &#39;auto-start&#39; &#39;auto-end&#39; &#39;top&#39; &#39;top-start&#39; &#39;top-end&#39; &#39;right&#39; &#39;right-start&#39; &#39;right-end&#39; &#39;bottom&#39; &#39;bottom-start&#39; &#39;bottom-end&#39; &#39;left&#39; &#39;left-start&#39; &#39;left-end&#39; 2 配置对象形式上面的方式可以传入响应式属性或者是静态的字符串，其实还可以传入一个对象。通过对象属性 options 的配置来个性化定制 tooltip 的功能 1&lt;button v-tooltip=&quot;&#123; content: &apos;You have new messages.&apos; &#125;&quot;&gt;&lt;/button&gt; content 显示的文本。可以是返回值或者 promise 的函数 classes 动态渲染样式类，有三种用法 classes: &#39;a b&#39; 空格隔开两个样式类 classes: [&#39;a&#39;, &#39;b&#39;] 数组形式 classes: tooltipClasses放一个响应式数据 targetClasses 将样式类添加到目标元素中 html 是否允许显示 HTML 内容 delay 显隐延迟时间 ，可以分开来写 { show: 500, hide: 100 } placement 就是显示方位，值看上面的修饰符列表 trigger 触发气泡的事件。多个事件之间用空格分隔 支持4个事件类型： hover, click, focus, manual 另外manual事件只能单独使用。trigger: &#39;manual&#39;。 该事件用于手动触发，就要跟 show字段一起使用 1234567&lt;button v-tooltip=&quot;&#123; content: &apos;Tooltip content here&apos;, show: isOpen, trigger: &apos;manual&apos;, &#125;&quot;&gt;A button&lt;/button&gt; show 是否显示 tooltip， 该字段用于手动控制 offset 位置偏移 (px) container 目标容器（选择器） template 内容模板，相当于自己定义了一个气泡 arrowSelector 用于获取模板气泡的箭头的CSS选择器 innerSelector 用于获取模板气泡的内容的CSS选择器 boundariesElement 气泡边界的 DOM autoHide 是否在鼠标悬停事件发生时关闭气泡 默认情况下，当 trigge 中包含了 hover事件，再次触发悬停或点击就会把气泡关闭 hideOnTargetClick 是否在鼠标点击事件发生时关闭气泡 loadingClass 异步加载内容时的样式 loadingContent 跟content作用一样，只是用于放异步操作没有结束时的显示内容 1234567&lt;button v-tooltip=&quot;&#123; content: asyncMethod(), loadingContent: &apos;Please wait...&apos;, loadingClass: &apos;content-is-loading&apos;, &#125;&quot;&gt;Hover me!&lt;/button&gt; 3 移动端处于性能之类的考虑，可能会选择适配到移动端时，禁止气泡功能。 那么在全局注册的时候，可以去设置一下适配。 1VTooltip.enabled = window.innerWidth &gt; 768 （二）组件方式1 组件形式的基本结构使用组件 v-popover 12345678910111213141516&lt;!-- 0 对于 v-popover 是跟之前 v-tooltip 指令一样都是可配置的 --&gt;&lt;v-popover offset=&quot;16&quot;&gt; &lt;!-- 1 气泡作用于该元素上 --&gt; &lt;button class=&quot;tooltip-target b3&quot;&gt;Click me&lt;/button&gt; &lt;!-- 2 就是气泡模板r --&gt; &lt;template slot=&quot;popover&quot;&gt; &lt;input class=&quot;tooltip-content&quot; v-model=&quot;msg&quot; placeholder=&quot;Tooltip content&quot; /&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;!-- 3 还可以放其他组件，就是一个插槽空位 --&gt; &lt;ExampleComponent char=&quot;=&quot; /&gt; &lt;/template&gt;&lt;/v-popover&gt; 可以按照以下的样式类去覆盖默认样式, &amp; 指代父类 12345678910111213141516171819.tooltip &#123; // ... &amp;.popover &#123; $color: #f9f9f9; .popover-inner &#123; background: $color; color: black; padding: 24px; border-radius: 5px; box-shadow: 0 5px 30px rgba(black, .1); &#125; .popover-arrow &#123; border-color: $color; &#125; &#125;&#125; 还可以注意下箭头的层级.tooltip-arrow { z-index: 1;} 2 v-popover 组件属性跟 v-tooltip类似，也有一点不同 open - 显隐控制 disabled - 是否禁用 1&lt;v-popover :disabled=&quot;true&quot;&gt;&lt;/v-popover&gt; placement - 同 v-tooltip delay - 同 v-tooltip trigger - 同 v-tooltip offset - 同 v-tooltip container - 同 v-tooltip boundariesElement - 同 v-tooltip popperOptions - 同 v-tooltip popoverClass - 使用此选项将不同的主题应用于弹出窗口。 popoverBaseClass - 样式基类。(默认是 &#39;tooltip popover&#39;). popoverWrapperClass - 包含箭头和内部内容的元素的类 popoverArrowClass - 箭头元素的类 popoverInnerClass - 气泡内容区元素的类 autoHide - 如果在外面单击，则隐藏弹出窗口 handleResize - 是否在弹窗大小改变后，自动调整弹出位置 配合事件 resize，在弹窗大小改变后触发 openGroup - 若设置了分组，将会统一关闭某组别的气泡和弹窗 openClass - 气泡弹出窗口时的类 3 组件的事件 update:open(Boolean) - 允许在弹窗中使用 .sync 修饰符 show apply-show - 在延迟显示后触发 hide apply-hide - 在延迟隐藏后触发 dispose auto-hide - 在弹窗外面点击时触发 close-directive - 当使用了 close 指令关闭弹窗时触发 close-group - 弹出窗口关闭时发出，因为显示了另一个开放组的弹出窗口。 resize - 如上 4 关闭指令 v-close-popover123456789101112131415&lt;v-popover&gt; &lt;button&gt;Click me&lt;/button&gt; &lt;template slot=&quot;popover&quot;&gt; &lt;!-- 默认禁用方式 --&gt; &lt;a v-close-popover&gt;Close&lt;/a&gt; &lt;!-- 启用/禁用 操作 --&gt; &lt;a v-close-popover=&quot;false&quot;&gt;Close&lt;/a&gt; &lt;a v-close-popover=&quot;true&quot;&gt;Close&lt;/a&gt; &lt;!-- 使用响应属性 --&gt; &lt;a v-close-popover=&quot;myBooleanProp&quot;&gt;Close&lt;/a&gt; &lt;!-- .all 修饰符关闭所有弹出窗口 --&gt; &lt;a v-close-popover.all&gt;Close All&lt;/a&gt; &lt;/template&gt;&lt;/v-popover&gt; 三、补充内容（一）tooltip 所有配置属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&#123; // Default tooltip placement relative to target element defaultPlacement: 'top', // Default CSS classes applied to the tooltip element defaultClass: 'vue-tooltip-theme', // Default CSS classes applied to the target element of the tooltip defaultTargetClass: 'has-tooltip', // Is the content HTML by default? defaultHtml: true, // Default HTML template of the tooltip element // It must include `tooltip-arrow` &amp; `tooltip-inner` CSS classes (can be configured, see below) // Change if the classes conflict with other libraries (for example bootstrap) defaultTemplate: '&lt;div class="tooltip" role="tooltip"&gt;&lt;div class="tooltip-arrow"&gt;&lt;/div&gt;&lt;div class="tooltip-inner"&gt;&lt;/div&gt;&lt;/div&gt;', // Selector used to get the arrow element in the tooltip template defaultArrowSelector: '.tooltip-arrow, .tooltip__arrow', // Selector used to get the inner content element in the tooltip template defaultInnerSelector: '.tooltip-inner, .tooltip__inner', // Delay (ms) defaultDelay: 0, // Default events that trigger the tooltip defaultTrigger: 'hover focus', // Default position offset (px) defaultOffset: 0, // Default container where the tooltip will be appended defaultContainer: 'body', defaultBoundariesElement: undefined, defaultPopperOptions: &#123;&#125;, // Class added when content is loading defaultLoadingClass: 'tooltip-loading', // Displayed when tooltip content is loading defaultLoadingContent: '...', // Hide on mouseover tooltip autoHide: true, // Close tooltip on click on tooltip target? defaultHideOnTargetClick: true, // Auto destroy tooltip DOM nodes (ms) disposeTimeout: 5000, // Options for popover popover: &#123; defaultPlacement: 'bottom', // Use the `popoverClass` prop for theming defaultClass: 'vue-popover-theme', // Base class (change if conflicts with other libraries) defaultBaseClass: 'tooltip popover', // Wrapper class (contains arrow and inner) defaultWrapperClass: 'wrapper', // Inner content class defaultInnerClass: 'tooltip-inner popover-inner', // Arrow class defaultArrowClass: 'tooltip-arrow popover-arrow', // Class added when popover is open defaultOpenClass: 'open', defaultDelay: 0, defaultTrigger: 'click', defaultOffset: 0, defaultContainer: 'body', defaultBoundariesElement: undefined, defaultPopperOptions: &#123;&#125;, // Hides if clicked outside of popover defaultAutoHide: true, // Update popper on content resize defaultHandleResize: true, &#125;,&#125; You can change the options during install with the arguments: 12import VTooltip from &apos;v-tooltip&apos;Vue.use(VTooltip, options) Or directly on package: 123import VTooltip from &apos;v-tooltip&apos;// Set custom CSS classVTooltip.options.defaultClass = &apos;my-tooltip&apos; （二）在线示例https://akryum.github.io/v-tooltip/#/]]></content>
      <categories>
        <category>插件工具</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uni-app 实战]]></title>
    <url>%2Funcategorized%2Funi-app%20%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[[TOC] 一、项目基础配置1 HBuilderX 工具对 uni-app 支持很好，一些 API 都不用去查，你只需要知道有这个东西，在写的时候会自动提示。 如输入 ulist 就会提示生成 Uniapp 的 list 组件。 若新增了文件，则必须重新编译。 2 开发平台第三方的开发能力，实际上就是在各个开发者平台去拿到 appid 和 appscret. 花点钱去认证开发者资格在启平台创建APP应用，就能拿到这些。如微信开放平台。 不同 API 支持不同的平台，此时需要圈起来不然在某一个不支持的平台会报错。 3 套路样式说明1）全局样式在 App.vue 中设定， 应用于各个页面的根视图容器组件 &lt;view class=&quot;page&quot;&gt;&lt;/view&gt; 123456.page &#123; width:100%; height:100%; background-color:#f7f7f7; position:absolute;&#125; 2）引入外部样式12345// 在一个页面文件夹中，除了 .vue 还可以有 css 文件@import url("xx.css") // 在.vue 的 style 标签中引入该样式文件// 背景图片， 一定是外部网络图background:url(https://xxxx) 3）文字超出省略显示12345.text &#123; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;&#125; 4）flex 嵌套布局123456789.father &#123; display:flex; flex-direction:column;&#125;.son &#123; display:flex; flex-direction:row;&#125; 5）阴影实现123.block &#123; box-shadow:3px 2px 10px #dedede; // x/y 偏移量，模糊程度，颜色&#125; 二、框架基础（一）项目结构与文件类型（MVVM思想）1 MVC用户操作页面（view），处理用户请求（controller路由+控制器），增删改查（数据层model） 2 MVVC之前，数据（JSON）通过 JS/JQ 操作DOM更改视图。 现在，用 viewModel 调度，当Model发生变化，视图同时改变，或反向（数据双向绑定） 3 数据双向绑定1）项目结构1234567891011121314- components 自定义组件目录- pages 页面目录- - .vue 单页面组件- - - template HTML模板，就是view层- - - script 就是 VM 协调者。其中的data属性就是 model- - - style- common 存放 css 等资源- static 存放图片等静态资源- store Vuex- unpackage 打包目录- App.vue 根组件，全局样式、应用级生命周期- main.js 入口文件，全局变量- manifes.json 各个平台的打包配置- pages 页面路由和基本配置 2）双向绑定12345678910111213141516171819202122232425262728293031&lt;template&gt;&lt;view&gt; &lt;!-- 2 &#123;&#123;title&#125;&#125; 绑定数据 --&gt; &lt;!-- 3 :value 绑定变量 --&gt; &lt;!-- 4 @change 绑定事件 --&gt; &lt;text&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;input type=&quot;text&quot; :value=&quot;title&quot; @change=&quot;change&quot;&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; title:&apos;wjy1&apos; // 1 定义数据 &#125; &#125;, methods: &#123; change(e)&#123; // 5 拿到事件对象和值 console.log(e.detail.value) // 6 改写 title 变量 this.title = e.detail.value &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; （二）全局（页面）标题（样式）与路由配置1 路由配置创建页面，pages/index/index.vue ，会自动到 pages 中添加该页面路由 1234567"pages":[ // 数组第一项为启动页 &#123; "path":'pages/xxxx', "style":&#123;&#125; &#125;, &#123;&#125;] 2 页面标题配置在路由的 style 中 123456789"pages":[ &#123; "path":'pages/xxxx', "style":&#123; "navigationBarTitleText":"该页面标题" &#125; &#125;, &#123;&#125;] 3 全局标题在 “globalStyle” 属性中 1234567891011"globalStyle": &#123; "navigationBarTextStyle": "black", // 导航栏颜色[black, white] "navigationBarTitleText": "Hello uniapp", // 导航栏标题 "navigationBarBackgroundColor": "#F8F8F8", // 导航栏背景颜色 "backgroundColor": "#F8F8F8", // 窗口背景色 "backgroundColorTop": "#F4F5F6", "backgroundColorBottom": "#F4F5F6", "mp-alipay": &#123; "titleBarColor": "#FFFFFF" &#125;&#125;, 4 开启下拉刷新和触底分页(配合 Loading)1）Pages.json 开启页面的 style 属性12345678910111213"pages": [ &#123; "path": "pages/index/index", "style": &#123; "navigationBarTitleText": "uni-app", "h5":&#123; "titleNView":false &#125;, "enablePullDownRefresh":true, // 下拉刷新 "onReachBottomDistance":true // 触底分页 &#125; &#125;], 2）页面中增加响应事件和 loading12345678910111213export default &#123; onPullDownRefresh()&#123; // 1 开启loading。 在小程序等原生顶部栏也有loading，执行 uin.showNavigationBarLoading() uni.showLoading(&#123; mask:true, // 遮罩防止用户点击 title:"请稍后..." &#125;) // 2 重新请求方法 // 3 注意在请求 complate 回调中要关闭 Loading 动画，执行 uni.stopPullDownRefresh() // 还有 uni.hideLoading() 或 uni.hideNavigationBarLoading() &#125;, onReachBottom()&#123;&#125;&#125; 5 沉浸渐进式标题导航栏12345678910111213"pages": [ &#123; "path": "pages/index/index", "style": &#123; "navigationBarTitleText": "uni-app", "app-plus":&#123; "titleNView":&#123; "type":"transparent" // 页面滑动，顶部导航栏有透明效果 &#125; &#125; &#125; &#125;], 6 顶部导航栏1）顶部导航栏H5，APP可能并不需要顶部导航栏，所以可以去掉， 也是在 pages.json中对某个页面的路由 style属性进行设置（微信小程序是去不掉的）。 其他端增加这个导航栏，需要调整上边距 123456789"path": "pages/index/index","style": &#123; "navigationBarTitleText": "uni-app", “navigationBarTitleStyle:'white', // 只有 white / black "navigationBarBackgroundColor":'#ffd655', "h5":&#123; // 设置 app-plus 也会应用到 H5，反之则覆盖 "titleNView":false &#125;&#125; 2）顶部自定义按钮 配合页面生命周期，监听标题栏按钮点击事件 1234567891011121314151617181920"path": "pages/index/index","style": &#123; "navigationBarTitleText": "uni-app", "h5":&#123; "titleNView":&#123; "type":"transparent", // 透明渐变 "buttons":[ &#123; "type":"share" // 分享 &#125;, &#123; "type":"home" // 主页 &#125;, &#123; "type":"forward" // 前进 &#125; ] &#125; &#125;&#125; 监听标题栏按钮事件 123onNavigationBarButtonTap(e)&#123; const index = e.index // 判断 index 值就行&#125; 分享到朋友圈（H5不支持）, 其他小程序平台需要配置分享时的appid信息 1234567891011uni.share(&#123; provider:'weixin', scene:'WXSenceTimeline', type:0, href:"", title:"uni-app分享", summary:"我正在与你分享", imageUrl:"xxx", success:()=&gt;&#123;&#125;, fail:()=&gt;&#123;&#125;&#125;) （三）App（页面）的生命周期1 应用生命周期1234onLaunch 初始化全局只触发一次onShow 页面展示就触发onHide 页面隐藏就触发onUniNViewMessage 对 nvue 页面发送的数据进行监听 2 页面生命周期12345678910onLoad 监听页面加载，参数为上个页面的传参onUnload 监听页面卸载onShow 页面显示onHide 页面隐藏onReady 页面初次渲染完成onPullDownRefresh 下拉事件。用于下拉刷新onReachBottom 触底。分页操作onNavigationBarButtonTap 原生页面标题按钮点击事件，参数是 objonBackPress 监听页面返回 3 页面跳转组件123&lt;navigator url="../index/index"&gt; &lt;view&gt;xxx&lt;/view&gt;&lt;/navigator&gt; （四）数据绑定与事件和组件动静态变量12345// 1 动态绑定属性变量 v-bind:或 :&lt;view :text:"text"&gt;&lt;/text&gt;// 2 事件绑定, tap 会覆盖 click 事件， longtap 替代 longpress&lt;input @input="change"&gt; （五）条件和列表渲染语法1 条件渲染123456789101112131415161718// 1 v-if 条件渲染&lt;tempalte v-if=&quot;isShow&quot;&gt;&lt;/tempalte&gt;&lt;tempalte v-else-if=&quot;!isShow&quot;&gt;&lt;/tempalte&gt;&lt;tempalte v-else&gt;&lt;/tempalte&gt;// 2 v-show 控制的是 display 属性 DOM 是存在的。&lt;tempalte v-show=&quot;isShow&quot;&gt;&lt;/tempalte&gt;// 3 三元运算&lt;tempalte v-if=&quot;sex === 1 ? true: false&quot;&gt;男&lt;/tempalte&gt;&lt;tempalte v-if=&quot;sex === 0 ? true: false&quot;&gt;女&lt;/tempalte&gt;export default &#123; data() &#123; return &#123; isShow:true, sex:1 &#125; &#125; &#125; 2 列表渲染123456789101112131415161718// 1 v-for 列表渲染// 2 :key 确保数据唯一性。防止如数组头部增加这样的操作&lt;view&gt; &lt;view v-for=&quot;(item, index) in arr&quot; :key=&quot;item.id&quot;&gt; &lt;view&gt;姓名&#123;&#123;item.name&#125;&#125;&lt;/view&gt; &lt;/view&gt;&lt;/view&gt;export default &#123; data() &#123; return &#123; arr:[ &#123;id:1,name:&apos;wjy&apos;, age:12&#125;, &#123;&#125; ] &#125; &#125; &#125; （六）多端兼容条件编译1 基本语义 #ifdef 仅某平台存在 #ifndef，除了某平台均存在 %PLATFORM%平台名称 endif结束标识 2 平台类别1234567APP-PLUSAPP-PLUS-NVUEH5MP-WEIXINMP-ALIPAYMP-BAIDUMP 3 使用方式JS, CSS, HTML, JSON 文件中都可以使用。 123&lt;!-- #ifdef H5 --&gt;&lt;view&gt;H5端&lt;/view&gt;&lt;!-- #endif --&gt; 三、组件（一）普通官网组件1 tabBar 底部栏配置 pages.json 的 “tabBar” 属性，定义基本的选中/非选中颜色，然后配置list的tab数组。 2 view 视图组件也是必备的，也是通用组件 3 swiper 轮播图组件就给出几个常用的属性, swiper-item 在 swiper 组件中宽高自动为 100%, 但是图片可能没有填满，所以要对图片进行CSS设置。 12345678910&lt;swiper :autoplay="true" 自动切换 :indecator-dots="true" 显示指示点 vertical:false 是否纵向滑动 current 当前滑块所在 index 0 开始 @change 滑块变化时触发 &gt; &lt;swiper-item&gt;&lt;view&gt;xxx&lt;/view&gt;&lt;/swiper-item&gt; &lt;swiper-item&gt;&lt;image src="xxx"&gt;&lt;/image&gt;&lt;/swiper-item&gt;&lt;/swiper&gt; 4 scroll-view 滚动区域1234567scroll-x 横向scroll-y 允许纵向滚动upper-threshold 距离顶部/左边 xx 距离，触发 @scrolltoupper 事件lower-threshold 距离底部/右边 xx 距离，触发 @scrolltolower 事件@scroll 滚动事件scroll-top(left) 设置竖向/横向滚动条位置 scroll-into-view 值为某子元素 id(不能以数字开头)，设置哪个方向可滚动，则在哪个方向滚动到该元素 需要对其中的元素进行样式设定 12345.hot &#123; width:100%; white-space:nowrap; 不换行&#125;// 横向的话，可能还要更改元素的 display:inline-block 5 video 视频组件12345678src 资源地址loop 是否循环播放muted 是否静音播放initial-time 初始播放位置秒duration 视频时长controls 是否显示播放控件（播放、暂停、进度、时间）// 弹幕相关page-gesture 非全屏模式下，是否开始亮度与音量调节手势 1）切页时的视频控制 uni.createVideoContext当我们点开图片之类的，希望视频暂停（H5上是跳转页面，所以不存在继续播放的问题） 12345678910111213// 1 页面进来获得视频对象onReady()&#123; this.videoContext = uni.createVideoContext('id') // 根据视频标签上的 id 属性获得&#125;// 2 当播放页面隐藏，视频暂停onHide()&#123; this.videoContext.pause()&#125;// 3 继续播放onShow()&#123; // 判断有效性，因为第一次进来是没这个对象的 this.videoContext &amp;&amp; this.videoContext.play()&#125; 2）禁止视频同时播放给每个视频 video 增加 id 属性和自定义属性（两个属性值是一样的，用于标识视频和播放视频），绑定 @play 事件 1234567891011121314151617181920// 只能播放一个视频play(e) &#123; const that = this const id = '' // 当前播放视频的id if (e) &#123; activeId = e.currentTarget.dataset.playindex that.videoContext = uni.createVideoContext(activeId) &#125; // 遍历暂停其他视频 const activeList = that.activeList for (let i=0; i&lt;activeList.length; i++)&#123; const id = activeList[i].id if(id != activeId) &#123; uni.createVideoContext(id).pause() &#125; &#125;&#125;// onHide()&#123;&#125; 也要处理视频暂停 6 input 输入框12345678910111213value 值type 表单类型 [text文本, number数字, idcard 身份证, digit带小数数字]password 是否密码类型placeholder 空内容占位符disabled 是否禁用maxlength 输入最大长度， -1 时不限制最大长度foucs 焦点adjust-position 键盘弹出是否上腿页面confirm-type 键盘右下角按钮文字，在 type=text 时有效, [search搜索]（通用）其他均为小程序用@input 输入@focus 聚焦@blur 失焦@confirm 点击完成按钮 7 image 图片资源123src 地址mode 裁剪、缩放模式 13 种 [scaleToFill 完全适配, aspectFill保持纵横比缩放]lazy-load 揽件在。针对 page 和 scroll-view 下的 Image 有效 8 表单组件1）按钮组件 button12345678size 按钮大小 default, minitype 按钮样式类型 [primary 蓝绿色, default 白色, warn 红色]plain 按钮是否镂空，背景色是否透明disabled 是否禁用form-type 用于 form 组件，设置后，点击会触发 submit/reset 事件hover-class 按下去的样式类, 设置为"none"就没点击效果loading 设置true时就是表示加载交互了,js控制@getuserinfo 点击该按钮，会返回获取到的用户信息（微信小程序） 2）form 表单 用的话的，需要用 去包裹那些按钮之类的组件 12@submit, 携带 form 中的数据，拿到 event.detail = &#123;value:&#123;name:value&#125;, formid:&#125;@reset，表单重置触发 实际使用 123456789101112131415&lt;form @submit="formSubmit"&gt; &lt;input name="username" type="text" value="" class="input" placeholder="请输入用户名" placeholder-class="graywords"/&gt; &lt;button type="primary" form-type="submit"&gt;登录&lt;/button&gt;&lt;/form&gt;&lt;script&gt;export default &#123; methods:&#123; formSubmit(e)&#123; const that = this const obj = e.detail.value // &#123;&#125; 包含了在各个表单组件中 name 属性对应的表单值 &#125; &#125;&#125;&lt;/script&gt; （二）自定义组件 自定义组件可以理解为自定义标签 1 自定义组件的开发1）创建组件在 components目录下直接创建，也是一个 .vue 单文件 2）定义组件名称 在template根节点上加上 name 属性 在 script 部分的 name属性上写相同的组件名 12345678910111213141516&lt;template name=&quot;errorJe&quot;&gt; &lt;view&gt;&#123;&#123;msg&#125;&#125;&lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&quot;errorJe&quot;, data() &#123; return &#123; msg:&apos;自定义 errorje 组件&apos; &#125;; &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 3）使用自定义组件12345678910111213141516171819// 1 导入组件，注意组件名import errorJe from '../../components/errorJe.vue'export default &#123; data() &#123; return &#123; title: 'Hello' &#125; &#125;, onLoad() &#123;&#125;, methods: &#123;&#125;, components:&#123; // 2 在当前页面组件中注册导入的自定义组件 errorJe &#125;&#125;// 使用自定义标签&lt;errorJe&gt;&lt;/errorJe&gt; 2 组件间传值1）父传子 父组件通过子组件提供的元素属性传值 :绑定变量动态传值 1&lt;errorJe msg=&quot;msg&quot; :auto=&quot;auto&quot;&gt;&lt;/errorJe&gt; 子组件通过props实例属性拿到值，每个自定义变量都是对象的形式定义 12345678export default &#123; props:&#123; msg:&#123; type:String, &#125;, showNum:0 // 默认值 &#125;&#125; 四、API1 发起请求 uni.request123456789101112131415161718192021222324// 与小程序一样，调用 api 时要注意 thisconst that = thisuni.request(&#123; url:'', method:"POST", // 必须大写 data:&#123; va1:xx &#125;, header: &#123; "Content-Type": "application/json", // 默认，可不写 &#125;, dataType: 'json', success:res =&gt; &#123; // 1 使用数据前，判断请求状态 res.data.status === 200 &amp;&amp; (var result = res.data.data) // 2 更新数据。如果使用的是箭头函数，可以直接使用 this that.list = result &#125;, fail:err =&gt; &#123;&#125;, complete:() =&gt; &#123;&#125;&#125;)// 后端要求传参，但是前端给控制的 URL 传法url:"https://xxx.com?key=&amp;key2=" 2 路由跳转 uni.navigateTo123456789// 可以通过 uni.navigateBack 返回原页面uni.navigateTo(&#123; url:'test?id=1&amp;name=xx'&#125;)// uni.switchTab 会关闭其他所有非 tab 页uni.switchTab(&#123; url: '/pages/index/index'&#125;); 会在下一个页面的 onLoad 中拿到参数s 3 图片预览 uni.previewImage 需要在图片上绑定 @click 12345urls 预览图片链接数组current 当前显示图片链接，不填则默认 urls 第一张loop 是否循环预览indicator 图片指示器success/fail/complate 1）自定义预览组件实现不用官方提供的预览，只有切换图片的效果。我们想自定义按钮、标题等。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// cover.vue 组件&lt;tempalte&gt; &lt;view class=&quot;black&quot;&gt; &lt;image :src=&quot;cover&quot; class=&quot;cover&quot; mode=&quot;widthFix&quot; @longpress=&quot;operator&quot; &gt;&lt;/image&gt; &lt;/view&gt;&lt;/tempalte&gt;&lt;script&gt; export default &#123; name:&apos;errorImage&apos;, data()&#123; return &#123; cover:&apos;&apos; &#125; &#125;, onLoad(params)&#123; let cover = params.cover this.cover = cover // 父组件传来的图片 src // 修改导航栏属性 uni.setNavigationBarColor(&#123; frontColor:&quot;#ffffff&quot;, backgroundColor:&apos;#000000&apos; &#125;) &#125;, methods:&#123; &#125; &#125;&lt;/script&gt;&lt;style&gt; .black &#123; background-color:#000000; width:100%; height:100%; display:flex; flex-direction:column; justify-content:center; position:fixed; &#125; .cover&#123; align-self:center; &#125;&lt;/style&gt; 2）路由跳转到自定义组件页面 因为是采用路由跳转，自动加了返回的按钮 123456&lt;navigation :url=&quot;../../cover/cover?key=xx&quot;&gt; &lt;image :src=&quot;xxxx&quot; class=&quot;xxx&quot; &gt;&lt;/image&gt;&lt;/navigation&gt; 3）增加图片交互功能 uni.showActionSheet 显示操作菜单，增加一些按钮（最多6个），还有一个默认出现的 “取消”按钮 123456789// 上面触发长按，执行 operator 方法// ...uni.showActionSheet(&#123; itemList:["下载", "aaa"], // 按钮文字数组 itemColor:'#000000', success:(e)=&gt;&#123; e.tapIndex // 按钮的位置 &#125;&#125;) 4 下载资源到本地1）下载资源 uni.downLoadFile （跨域）下载资源到本地，客户端发起 GET 请求，返回文件的本地临时路径 12url 资源路径success 下载成功后以临时文件路径的形式传给页面 文件操作肯定是延迟的，所以配合 loading 12345678910let url = urluni.showLoading(&#123; title:'图片保存中...'&#125;)uni.downLoadFile(&#123; url:url, success:(res)=&gt; &#123; res.tempFilePath // 文件路径 &#125;&#125;) 出现本机和服务器地址不一致，一般在 H5端出现跨域问题。此时需要后端去开启一些配置。 2）保存图片到本地 uni.saveImageToPhotosAlbum接着上面的代码的 success 回调写，假设我们这里是图片资源。 H5 和 支付宝小程序是不支持的。微信小程序需要打开调试模式 1234567891011121314filePath 可以是临时路径uni.saveImageToPhotosAlbum(&#123; filePath:url, success:()=&gt;&#123; uni.showToast(&#123; title:'保存成功', duration:2000 &#125;) &#125;, complate:()=&gt;&#123; uni.hideLoading() &#125;&#125;) 5 第三方登录 uni.login H5 不支持，要使用条件编译排除 1）微信小程序登录 基本页面构建 1234567891011121314151617181920212223242526272829303132&lt;!-- 1 第三方登录H5不支持，所以隐藏掉 --&gt;&lt;!-- #ifndef H5 --&gt;&lt;view class="third-wapper"&gt; &lt;!-- 与上面表单的分割线 --&gt; &lt;view class="third-line"&gt; &lt;view class="single-line"&gt; &lt;view class="line"&gt;&lt;/view&gt; &lt;/view&gt; &lt;view class="third-words"&gt;第三方账号登录&lt;/view&gt; &lt;view class="single-line"&gt; &lt;view class="line"&gt;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 2 5+app 用qq/微信/微博 登录 小程序用微信小程序登录(data-logintype) h5不支持 --&gt; &lt;view class="third-icos-wapper"&gt; &lt;!-- 嵌入各平台图片，点击后触发 --&gt; &lt;!-- #ifdef APP-PLUS --&gt; &lt;image src="../../static/icos/weixin.png" data-logintype="weixin" @click="appOAuthLogin" class="third-ico"&gt;&lt;/image&gt; &lt;image src="../../static/icos/QQ.png" data-logintype="qq" @click="appOAuthLogin" class="third-ico" style="margin-left: 80upx;"&gt;&lt;/image&gt; &lt;image src="../../static/icos/weibo.png" data-logintype="sinaweibo" @click="appOAuthLogin" class="third-ico" style="margin-left: 80upx;"&gt;&lt;/image&gt; &lt;!-- #endif --&gt; &lt;!-- 3 微信开放能力，获取用户信息的按钮 --&gt; &lt;!-- #ifdef MP-WEIXIN --&gt; &lt;button open-type='getUserInfo' @getuserinfo="wxLogin" class="third-btn-ico"&gt; &lt;/button&gt; &lt;!-- #endif --&gt; &lt;/view&gt;&lt;/view&gt;&lt;!-- #endif --&gt; css样式 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* 1 第三方登录 start */.third-wapper &#123; width: 100%; margin-top: 60upx;&#125;/* 2 分割线容器 */.third-line &#123; display: flex; flex-direction: row; justify-content: center&#125;/* 3 分割线文字 */.third-words &#123; color: #A9A9A9; font-size: 13px; display: flex; flex-direction: column; justify-content: center;&#125;/* 4 线条 */.single-line &#123; padding: 15upx 20upx; width: 25%; align-items: center;&#125;/* 5 各平台图标容器布局 */.third-icos-wapper &#123; margin-top: 30upx; display: flex; flex-direction: row; justify-content: center&#125;/* 6 图标大小 */.third-ico &#123; width: 60upx; height: 60upx;&#125; 实现微信小程序端的微信登录 12345678910111213141516171819202122232425262728293031323334353637// 微信提供的获取用户基本信息的按钮，open-type='getUserInfo' @getuserinfo="wxLogin"wxLogin(e)&#123; var me = this; // 1 通过微信开发能力，获得微信用户的基本信息 var userInfo = e.detail.userInfo; // 2 实现微信登录 uni.login(&#123; provider: "weixin", success(loginResult) &#123; // 3 获得微信登录的code：登录授权码 var code = loginResult.code; // 4 设置登录到哪个对于的微信小程序，大家可以根据自己的后端去实现业务参数 // [0:NEXT超英预告][1:超英预告][2:NEXT学院电影预告] var loginToWhichMP = 1; // 5 发起请求 uni.request(&#123; url: me.serverUrl + "/mpWXLogin/" + code, data: &#123; "avatarUrl": userInfo.avatarUrl, "nickName": userInfo.nickName, "whichMP": loginToWhichMP &#125;, method: "POST", success(userResult) &#123; var userInfo = userResult.data.data; // 6 保存用户信息到全局的缓存中 uni.setStorageSync("globalUser", userInfo); // 7 切换页面跳转，使用tab切换的api uni.switchTab(&#123; url: "../me/me" &#125;); &#125; &#125;); &#125; &#125;)&#125; 后端处理登录（java） 12345678910111213141516171819// 1 根据微信登录的处理流程，要携带4个参数去访问微信提供的请求// https://api.weixin.qq.com/sns/jscode2session?appid=APPID&amp;secret=SECRET&amp;js_code=JSCODE&amp;grant_type=authorization_code// 2 这些敏感数据都是放在后端的String appid = xxxx;String secret = xxxx;String url = "https://api.weixin.qq.com/sns/jscode2session";Map&lt;String, String&gt; param = new HashMap&lt;&gt;();param.put('addid', appid);param.put('secret', secret);param.put('js_code', code); // code 是前端执行 wx.login 得到的登录凭证param.put('grant_type', "authorization_code");// 3 发起请求// 得到的字符串，要自己转换。session_key, openid(用户唯一Id)String wxResult = HttpClientUtil.doGet(url, param); // 4 用户查询...处理用户信息... 2）APP 登录 实现 APP 授权登录，总体和 APP 差不多 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455appOAuthLogin(e) &#123; var me = this; // 1 获取用户的登录类型 var logintype = e.currentTarget.dataset.logintype; // 2 授权登录 uni.login(&#123; provider: logintype, success(loginRes) &#123; // 3 授权登录成功以后，获取用户的信息 uni.getUserInfo(&#123; provider: logintype, // 服务商类型 success(info) &#123; // 4 根据不同平台获取信息的方式不同，去获取有差异的信息字段 var userInfo = info.userInfo; var face = ""; var nickname = ""; var openIdOrUid = ""; if (logintype == "weixin") &#123; // ... &#125; else if (logintype == "qq") &#123; // ... &#125; else if (logintype == "sinaweibo") &#123; // ... &#125; // 5 调用开发者后台，执行一键注册或登录 uni.request(&#123; url: me.serverUrl + "/appUnionLogin/" + logintype, data: &#123; "openIdOrUid": openIdOrUid, "nickname": nickname, "face": face &#125;, method: "POST", success(result) &#123; if (result.data.status == 200) &#123; var userInfo = result.data.data; // 6 保存用户信息到全局的缓存中 uni.setStorageSync("globalUser", userInfo); // 7 切换页面跳转，使用tab切换的api uni.switchTab(&#123; url: "../me/me" &#125;); &#125; &#125; &#125;) &#125; &#125;) &#125; &#125;);&#125;, 6 插件使用 在 HBuilderX 中可以创建模块项目，里面有官方所有的插件组价的代码。 也可以去插件市场下载 1）图片剪裁可以去下载 APP， hello uni-app，里面可以看到现有官方原生组件 如果是从 HBX 里创建的模板项目，则可以去 pages/tempalte/crop里看（版本更新下可能目录有变化） 2）ColorUi是插件市场排名第二的插件库，但是因为作者一个人，所以只是实现，而没有相应的文档。 建议看这篇 https://www.jianshu.com/p/dc5f29a91c0f 五、业务处理（一）全局变量和状态1 全局变量 - 公共组件1）创建 common 目录common/common.js 1234567// 1 应用场景：全局请求基地址const serverUrl = "https://xxx" // 生产环境// const serverUrl = "https://xxx2" // 开发环境export default &#123; serverUrl&#125; 2）导入 common 并使用123456import common from '../../common/commin.js'onLoad:()=&gt;&#123; const serverUrl = common.serverUrl // ...&#125; 2 全局变量 - Vue.prototype 挂载到 Vue 实例中 1）main.js 扩展 Vue 实例1Vue.prototype.serverUrl = "xxxx" // 开发/生产环境 2）从实例中拿123onLoad:() =&gt; &#123; const url = this.serverUrl&#125; （二）数据处理1 :data-* 自定义属性场景，点击某个列表项获取该项的标识值 123456789101112131415161718192021&lt;template&gt; &lt;view v-for=&quot;(item, idx) in Lists&quot;&gt; &lt;view :data-list=&quot;idx&quot; @click=&quot;fn&quot;&gt;&lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data()&#123; return &#123; lists:[] &#125; &#125;, methods:&#123; fn(e)&#123; // 获取 this.id = e.currentTarger.dataset.idx this.lists[id] = xxxx &#125; &#125; &#125;&lt;/script&gt; 2 分页处理1）通用参数一般在分页实现的逻辑中，必定会使用到几个参数和概念 key， 搜索内容或关键词 page，查询的页面的页数 pageSize，每页显示的条数 total，总页数 records，总记录数 其他需要配合的处理 loading 触底响应分页 input 绑定输入事件 2）请求和分页逻辑12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 1 在 data 部分，需要预留几个必要的变量export default &#123; data()&#123; return &#123; dataList:[], keywords:'', // 搜索关键字 page:1, // 当前页数 totalPages:1 // 总页数 &#125; &#125;, methods:&#123; // 2 分页方法 pagedTrailerList(key, page, pageSize)&#123; const that = this // loading uni.showLoading(&#123; mask:true, title:'请稍后...' &#125;) uni.showNavigationBarLoading() // 执行请求，拼接查询参数 uni.request(&#123; url:`xxx?keywords=$&#123;key&#125;&amp;page=$&#123;page&#125;&amp;pageSize=$&#123;pageSize&#125;`, method:'POST', success:res =&gt; &#123; // 验证请求状态 if(res.data.status === 200) &#123; // 更新 data 绑定变量 var tempList = res.data.data.rows that.dataList = [...that.dataList, ...tempList] // 拼接数组 that.totalPages = res.data.data.total // 总页数 that.page = page // 当前页数 &#125; &#125;, complete:() =&gt; &#123; // 关闭 loading uni.hideNavigationBarLoading() uni.hideLoading() &#125; &#125;) &#125;, // 3 搜索方法 search(e) &#123; const that = this let value = e.detail.value // 假设通过分页组件，拿到了 page, pageSize 分别为 1， 15(web 端) // 手机端一般是通过触底分页 that.keywords = value that.dataList = [] that.pagedTrailerList(value, 1, 15) &#125; &#125;, // 4 触底分页响应 onReachBottom()&#123; const that = this let page = that.page + 1 // 查询下一页 let keywords = that.totalPages // 搜索值 let totalPages = that.totalPages // 总页数 // 若需要分页的分页数与总页数相等，说明没有更多数据，就不分页 page &gt; totalPages &amp;&amp; return // 执行分页方法 that.pagedTrailerList(keywords, page, totalPages) &#125;&#125; 3 data 复杂数据加载在 HTML 部分如果绑定了 obj.xxx， 在 data 定义改对象变量时，没有定义这个 xxx 属性。那么在 created 生命周期的时候可能就拿不到这个 xxx 的值。 这是因为只有在 data 属性中定义的变量才是响应式的 123&lt;block v-if="obj.xxx"&gt; &lt;view&gt;&#123;&#123;obj.xxx&#125;&#125;&lt;/view&gt;&lt;/block&gt; （三）页面控制1 动画创建 - uni.createAnimation 不支持 H5，所以要条件编译。 1）创建动画数据对象123456789101112131415161718192021222324252627282930313233343536export default &#123; data()&#123; return &#123; // 1 动画配置属性 animationData:&#123;&#125; &#125; &#125;, onLoad:()=&gt;&#123; // 2 页面加载 - 创建临时动画对象 this.animation = uni.createAnimation() &#125;, onUnload:()=&gt;&#123; // 3 页面卸载 - 清除动画数据 this.animationData = &#123;&#125; &#125;, methods:&#123; // 4 实现动画效果 praiseMe()&#123; // Y轴偏移, 显示， step 表示该组动画结束 this.animation.translateY(-60).opacity(1).step(&#123; duration:400 &#125;) // 5 导出临时动画数据给实例属性变量，实现动画的效果 this.animationData = this.animation.export() // 6 延迟还原动画 setTimeout(() =&gt; &#123; this.animation.translateY(0).opacity(0).step(&#123; duration:0 &#125;) this.animationData = this.animation.export() &#125;.bind(this), 500) &#125; &#125;&#125; 2）挂载到组件元素属性上1&lt;view :animation="animationData"&gt;&lt;/view&gt; 3）样式设置对于要进行动画的组件，opacity一开始最好设置为0 2 类似搜索框的样式实现 用 flex 中心对齐图标和input 更改容器背景色与 input 一致 视觉上像是 input 延长并包裹了图标 给 input 增加 z-index 以不被其他内容遮挡 给内容区增加 margin-top 以不被 Input 遮挡 （四）用户页面1 登录显示通过登录状态来判断用户是否登录，用 v-if 来区别展示未登录时默认的用户占位信息（如默认图片，提示登录按钮，其实是用 组件包裹）。 2 用户登录页面一般会有图片，然后是账号密码输入框（带Icon）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;template&gt;&lt;form @submit=&quot;formSubmit&quot;&gt; &lt;view class=&quot;body&quot;&gt; &lt;view class=&quot;face-wapper&quot;&gt; &lt;image src=&quot;&quot; class=&quot;face&quot;&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class=&quot;info-wapper&quot;&gt; &lt;label class=&quot;words-lbl&quot;&gt;账户&lt;/label&gt; &lt;input name=&quot;username&quot; type=&quot;text&quot; value=&quot;&quot; class=&quot;input&quot; placeholder=&quot;请输入用户名&quot; placeholder-class=&quot;graywords&quot;/&gt; &lt;/view&gt; &lt;view class=&quot;info-wapper&quot; style=&quot;margin-top:40rpx;&quot;&gt; &lt;label class=&quot;words-lbl&quot;&gt;密码&lt;/label&gt; &lt;input name=&quot;password&quot; type=&quot;text&quot; password=&quot;true&quot; value=&quot;&quot; class=&quot;input&quot; placeholder=&quot;请输入密码&quot; placeholder-class=&quot;graywords&quot;/&gt; &lt;/view&gt; &lt;button type=&quot;primary&quot; style=&quot;margin-top:60rpx; width:90%&quot; form-type=&quot;submit&quot;&gt;注册/登录&lt;/button&gt; &lt;/view&gt; &lt;/form&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods:&#123; // 拿到表单值 formSubmit(e)&#123; const that = this // &#123;&#125; 包含了在各个表单组件中 name 属性对应的表单值 const obj = e.detail.value &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .body&#123; border-top:solid 1px #DBDBDA; padding:0 40rpx; &#125; .facr-wapper &#123; display:flex; flex-direction:row; justify-content:center; margin-top:120rpx; margin-bottom:120rpx; &#125; .info-wapper&#123; display:flex; flex-direction:row; justify-content:center; border-buttom:solid 1px #DBDBDA; padding-bottom:20rpx; &#125; .face &#123; width:160rpx; height:160rpx; &#125; .input &#123; width:500rpx; margin-left:40rpx; &#125; .words-lbl&#123; color:#808080; &#125; .graywords &#123; color:#EAEAEA &#125;&lt;/style&gt; 3 发起登录请求 uni.request接上上面的 formSubmit 方法 1234567891011121314151617// ... 发起用户登录请求，发送账号密码const serverUrl = that.serverUrluni.request(&#123; url:serverUrl + xxx, data:&#123; username, password &#125; method:'POST', success:(res)=&gt;&#123; // 检查响应状态 if (res.data.status === 200) &#123; const userInfo = res.data.data // ... 缓存 &#125; &#125;&#125;) 4 用户信息缓存 uni.setStorageSync 和登录失败获得的用户信息需要缓存，在该登录状态周期内一直可以重复使用。 API 的话一般都是使用同步，异步会有一定问题，用在特殊场景。 1234567891011121314151617success:(res)=&gt;&#123; if (res.data.status === 200) &#123; const userInfo = res.data.data // 缓存用户信息 uni.setStorageSync('globalUser', userInfo) // 切换跳转到用户个人页面 uni.swichTab(&#123; url:'../me/me' &#125;) &#125; else if(res.data.status === 500) &#123; uni.showToast(&#123; title:res.data.msg, duration:2000, image:'../../static/icons/xxx.png' &#125;) &#125;&#125; 5 拿到缓存中的用户信息 uni.getStorageSync页面加载后，从缓存中取出个人信息 1234567891011121314151617181920export default &#123; data()&#123; return &#123; userIsLogin: false, // 用户登录状态 userInfo:&#123;&#125; // 用户对象 &#125; &#125;, onShow()&#123; const that = this const userInfo = uni.getStorageSync('globalUser') // 登录态判空后再获取用户数据 if (userInfo != null &amp;&amp; userInfo != '' &amp;&amp; userInfo != undefined)&#123; that.userIsLogin = true that.userInfo = userInfo &#125; else &#123; that.userIsLogin = false that.userInfo = &#123;&#125; &#125; &#125;&#125; 上面的判空方法，明显就是可以提取为全局方法。一样去扩展 Vue 那么可以完全取代上面的写法， this.getGlobalUser(&#39;globalUser&#39;) 12345678910// main.jsVue.prototype.getGlobalUser = function(key) &#123; // 缓存中取 const userInfo = uni.getStorageSync(key) if (userInfo != null &amp;&amp; userInfo != '' &amp;&amp; userInfo != undefined)&#123; return userInfo &#125; else &#123; return null &#125;&#125; 6 用户个人信息详情页1）页面骨架包括，头像、昵称（其他都是类似的） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;template&gt; &lt;!-- 页面容器 --&gt; &lt;view class=&quot;page page-fill&quot;&gt; &lt;view class=&quot;page-block info-list&quot;&gt; &lt;!-- 1 头像 --&gt; &lt;view class=&quot;item-wapper face-line-upbottom&quot; @click=&quot;operator&quot;&gt; &lt;view class=&quot;info-words&quot;&gt;头像&lt;/view&gt; &lt;view class=&quot;right-wapper&quot;&gt; &lt;image :src=&quot;globalUser.faceImage&quot; class=&quot;face&quot;&gt;&lt;/image&gt; &lt;view class=&quot;arrow-block&quot;&gt; &lt;image src=&quot;../../static/icos/left-gray-arrow.png&quot; class=&quot;arrow-ico&quot;&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 分割线 --&gt; &lt;view class=&quot;line-top&quot;&gt; &lt;view class=&quot;line&quot;&gt;&lt;/view&gt; &lt;/view&gt; &lt;!-- 2 昵称 --&gt; &lt;view class=&quot;item-wapper&quot; @click=&quot;modifyNickname&quot;&gt; &lt;view class=&quot;info-words&quot;&gt;昵称&lt;/view&gt; &lt;view class=&quot;right-wapper&quot;&gt; &lt;view class=&quot;gray-fields&quot;&gt; &#123;&#123;globalUser.nickname&#125;&#125; &lt;/view&gt; &lt;view class=&quot;arrow-block&quot;&gt; &lt;image src=&quot;../../static/icos/left-gray-arrow.png&quot; class=&quot;arrow-ico&quot;&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;line-top&quot;&gt; &lt;view class=&quot;line&quot;&gt;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;footer-wapper&quot;&gt; &lt;view class=&quot;footer-words&quot; @click=&quot;cleanStorage&quot;&gt; 清理缓存 &lt;/view&gt; &lt;view class=&quot;footer-words&quot; style=&quot;margin-top: 10upx;&quot; @click=&quot;logout&quot;&gt; 退出登录 &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt; 2）CSS 样式控制12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/* 页面铺满屏幕 *//* 1 保证页面背景色 */.page-fill &#123; width:100%; height: 100%; position: absolute;&#125;/* 2 页面内边距 */.info-list &#123; /* margin-top: 20upx; */ padding: 0upx 30upx;&#125;/* 3 信息容器的定位布局 */.item-wapper &#123; display: flex; flex-direction: row; justify-content: flex-start;&#125;.face-line-upbottom &#123; margin-top: 20upx; padding-top: 20upx; padding-bottom: 20upx;&#125;/* 4 文字的设置 */.info-words &#123; color: #333333; font-size: 16px; width: 25%; line-height: 80upx;&#125;.gray-fields &#123; font-size: 14px; color: darkgray; line-height: 80upx;&#125;/* 5 flex 右侧布局 */.right-wapper &#123; width: 80%; display: flex; flex-direction: row; justify-content: flex-end;&#125;/* 6 图片的设置 */.face &#123; width: 80upx; height: 80upx; border-radius: 50%;&#125;/* 7 点击箭头的定位 */.arrow-block &#123; margin-left: 10upx; line-height: 86upx;&#125;/* 8 箭头本身大小 */.arrow-ico &#123; width: 30upx; height: 30upx;&#125;/* 9 分割线 */.line-top &#123; margin-top: 20upx;&#125;/* 10 底部按钮操作 start */.footer-wapper &#123; position: fixed; bottom: 0; display: flex; flex-direction: column; width: 100%;&#125;/* 11 底部按钮文字 */.footer-words &#123; text-align: center; background-color: white; padding: 20upx; color: #333333; font-size: 16px;&#125; 3）渲染用户信息12345onShow()&#123; var me = this; var globalUser = me.getGlobalUser("globalUser"); me.globalUser = globalUser;&#125; 7 清理本地缓存 uni.clearStorageSync有个类似的uni.removeStorage是清除单个缓存。 页面分别对清理缓存和注销绑定了方法，实现这方法 12345678cleanStorage(e)&#123; uni.clearStorageSync() uni.showToast(&#123; title:'清理缓存成功', mask:false, duration:1500 &#125;)&#125; 8 用户退出用户退出不单单是让前端部分的缓存清理，还要经过后端去清理用户的登录态 12345678910111213141516171819logout()&#123; // 直接使用 vue 挂载的实例方法来获取用户信息 const globalUser = this.getGlobalUser('globalUser') uni.request(&#123; url:'xxx?userId=$&#123;globalUser.id&#125;', mthod:'POST', success:(res)=&gt;&#123; // 响应200，说明用户在后端已经完成退出 if (res.data.status === 200)&#123; // 清理缓存 uni.removeStorageSync('globalUser') // 页面跳转 uni.switchTab(&#123; url:'../me/me' &#125;) &#125; &#125; &#125;)&#125; 9 用户头像相关1）头像预览、上传和功能菜单给图片绑定事件 @click，显示菜单[预览，上传] 1234567891011121314151617181920212223242526272829303132operator()&#123; const globaUser = this.getGlobalUser('globalUser') // 1 拿到用户数据 // 2 底部弹出菜单 uni.showActionSheet(&#123; itemList:['查看我的头像', '从相册选择上传'], success:(res)=&gt;&#123; const index = res.tapIndex if (index === 0) &#123; // 3 预览头像 var faceArr = [].push(globalUser.faceImage) uni.previewImage(&#123; urls:faceArr, // 因这个属性要数组，所以要构建一个数组 current:faceArr[0] &#125;) &#125; else if (index === 1) &#123; // 4 相册中选择图片 uni.chooseImage(&#123; count:1,// 最多选择张数 sizeType:['compressed'], // 压缩还是原图 sourceType:['album'], // 图片来源 success:(res) =&gt; &#123; var tempFilePath = res.tempFilePath[0] // 5 拿到 图片临时路径 跳到图片选择页面 uni.navigationTo(&#123; url:'xxx?tempFilePath=$&#123;tempFilePath&#125;' &#125;) &#125; &#125;) &#125; &#125; &#125;)&#125; 2）头像上传和重新选择的页面 底部2个按钮，重选和确认。顶部标题还有文字（pages.json中改），还有返回箭头 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160&lt;template&gt;&lt;view class=&quot;page page-fill&quot;&gt; &lt;view class=&quot;pending-wapper&quot;&gt; &lt;image id=&quot;face&quot; :src=&quot;tempFace&quot; class=&quot;pending-face&quot; mode=&quot;scaleToFill&quot;&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class=&quot;notice&quot;&gt; &lt;view class=&quot;notice-words&quot;&gt; * 请从相册中选择等比宽高的图片噢~ &lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;footer-opertor&quot;&gt; &lt;view class=&quot;opertor-words&quot; @click=&quot;changePendingFace&quot;&gt; 重新选择 &lt;/view&gt; &lt;view class=&quot;opertor-words&quot; @click=&quot;upload&quot;&gt; 确认上传 &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; tempFace: &quot;&quot; // 图片 &#125;; &#125;, // 1 获取传过来的图片临时路径 onLoad(params) &#123; var tempFilePath = params.tempFilePath; this.tempFace = tempFilePath; &#125;, methods: &#123; // 2 重新去相册中选择图片 changePendingFace() &#123; var me = this; uni.chooseImage(&#123; count: 1, sizeType: [&quot;compressed&quot;], sourceType: [&quot;album&quot;], success(res) &#123; // 获得临时路径 var tempFilePath = res.tempFilePaths[0]; me.tempFace = tempFilePath; &#125; &#125;) &#125;, // 3 确认上传功能 uni.uploadFile upload() &#123; var me = this; // 4 用户信息，用户传递用户 id var globalUser = me.getGlobalUser(&quot;globalUser&quot;); // 5 上传 loading uni.showLoading(&#123; mask: true, title: &quot;上传中，请稍后&quot; &#125;); // 6 上传请求 uni.uploadFile(&#123; url: me.serverUrl + &quot;/user/uploadFace?userId=&quot; + globalUser.id, // 服务器 filePath: me.tempFace, // 需要上传的资源路径 name: &quot;file&quot;, // 文件对应的 key，服务器可以用这个 key 得到文件二进制内容 // 7 在 header 中增加用户 id 和 token（会话标识） // token 在用户登录时拿到 // 在后端会同时取到到2个字段作为准入条件 header: &#123; &quot;headerUserId&quot;: globalUser.id, &quot;headerUserToken&quot;: globalUser.userUniqueToken &#125;, success(res) &#123; var resDataStr = res.data; // 8 解析 JSON 数据 var resData = JSON.parse(resDataStr); if (resData.status == 200) &#123; // 9 获得最新的用户数据 var userInfo = resData.data; // 10 更新用户信息的缓存，并返回到之前的页面 uni.setStorageSync(&quot;globalUser&quot;, userInfo); uni.navigateBack(&#123; delta: 1 &#125;) &#125; else if (resData.status == 502 || resData.status == 500) &#123; // 11 异常提示 uni.showToast(&#123; title: res.data.msg, image: &quot;../../static/icos/error.png&quot;, duration: 2000 &#125;) &#125; &#125;, // 12 关闭 loading complete() &#123; uni.hideLoading(); &#125; &#125;); &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; /* 页面铺满屏幕 */ .page-fill &#123; width:100%; height: 100%; position: absolute; background: black; &#125; .pending-wapper &#123; display: flex; flex-direction: row; justify-content: center; margin-top: 40upx; &#125; .pending-face &#123; width: 600upx; height: 600upx; &#125; .notice &#123; display: flex; flex-direction: row; justify-content: flex-end; &#125; .notice-words &#123; color: gray; font-size: 13px; margin-top: 30upx; width: 600upx; &#125; /* 底部操作 start */ .footer-opertor &#123; position: fixed; bottom: 0; border-top: #515050 solid 1px; width: 100%; display: flex; flex-direction: row; justify-content: space-between; padding: 30upx; &#125; .opertor-words &#123; color: #e8e5e5; font-size: 16px; width: 200upx; &#125; /* 底部操作 end */&lt;/style&gt; 10 其他信息修改每个表单的信息修改，都需要创建一个页面来操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 1 在各个信息表单上绑定按钮事件// 2 父页面触发事件， 跳转到该表单对应的修改页上uni.navigateTo(&#123; url:'xxx'&#125;)// 3 子页面也是从缓存中拿到用户信息,// 然后在子页面相应地方绑定数据， 一般是 input 组件// 配合 button 提交按钮export default &#123; data()&#123; return &#123; globalUser:&#123;&#125; &#125; &#125;, onLoad()&#123; let globalUser = this.getGlobalUser('globalUser') this.globalUser = globalUser &#125;, methods:&#123; // 4 提交事件 formSubmit(e) &#123; let that = this let nickname = e.detail.value.nickname // 5 发起修改请求(这种请求都是需要携带 token) uni.request(&#123; url:'xx', header: &#123; "headerUserId": that.globalUser.id, "headerUserToken": that.globalUser.userUniqueToken &#125;, data:&#123; userId, nickname &#125;, method:'POST', // 6 每次申请回来都要更新用户数据 success:(&#123;data&#125;) =&gt; &#123; if (data.status === 200) &#123; let userInfo = data.data uni.setStorageSync('globalUser', userInfo) uni.navigateBack(&#123; delta:1 &#125;) &#125; else if (data.status === 200 || data.status === 500) &#123; uni.showToast(&#123; title:data.data.msg, image:'error.png', duration:2000 &#125;) &#125; &#125; &#125;) &#125; &#125;&#125; 其他信息的修改区别，可能就是 input 的类型不一样而已。 六、发布与上线（一）各平台编译发布1 编译发布 H5manifest.json 配置一下 H5 的页面标题，就可以直接发布打包了。如果不写域名，则需要自己去弄web服务器容器（打包后是运行不了的）。打包后的路径：unpakcage/dist/build/h5 在HBuilder 里也有打包后的项目路径。 2 微信小程序发布1）拿到微信开发者平台的 appid 配置一下2）发布微信小程序操作会自动填入小程序名称和appid。然后重新进行编译操作 3）等待微信开发者工具启动4）上传到微信开发者平台去审核在微信开发者工具中点击上传， 先去掉 HTTPS 协议。 然后去开发者平台，去操作提交审核。 3 APP 打包发布1）SDK配置需要获取各个平台的 appid 之类的参数配置 2）基本配置APP名称，图标等。 app启动图配置。 app模块授权配置。 3）安卓app打包原生app云打包。选择安卓，使用 DCLOUD 证书。是提供给平台打包的，不是在本地的。所以要等待打包后的下载地址。 4）IOS 打包选择IOS， 支持ipone，使用苹果证书（需要注册苹果开发者，要花钱），然后有一个 apple appid（该id还对应个秘钥），填入证书原件。 若是选择越狱。就不用选证书了。可以直接打包。也是提交到打包服务器，然后提供给我们下载的URL。 （二）服务器准备 + nginx购买云服务器，就有一个公网IP。然后整个云服务器就是作为一个使用实例。 1 安全组（防火墙）每台机器都有防火墙，在云服务器里就是安全组。可以自定义规则（端口的开放情况） 一些软件都有固定的连接端口，所以要打开相应的端口 一般会有一键放通功能，就是自动打开一些常用的端口 22(linux), 3389, ICMP, 80（http请求默认）, 443(ssr), 20, 21 也会有 all 的配置选项，建议直接删除这个规则。不需要开放所有端口 2 设定服务器实例密码可以对服务器设定连接密码。用户名一般是 root。 3 传送 nginx 到服务器，使用 filezilla 工具基本操作就是，输入主机名（公网IP地址）+用户名（一般默认是root）+密码+端口（linux默认22） 左边是本地pc目录，右边是服务器linux目录 就是将 nginx.tar.gz 包拉到右边，一般是 home目录装软件 （三）服务器环境搭建1 PuTTY 和 SecureCRT 连接服务器 2个选一个就行，这里选 CRT 1）新建会话输入主机名+端口+用户名 2）会话名称一般是 ip + 应用名字 3）连接输入密码4）调整对话框的字体等样式选项 - 字体设置 2 通过命令操作服务器1）找到并解压 nginx cd /， 进入根目录 ls， 列出目录 cd home， 进入 home 目录。找到刚才 nginx 解压 tar 包， tar -zxvf nginx-1xx.tar.gz（ 按 tab 可以补全文件名） 2）安装 nginx 基础运行环境 yum -y install gcc-c++， 安装nginx必须的运行环境 yum -y install pcre-devel yum -y install zlib-devel yum -y install openssl opensll-devel 3）安装 nginx ll， 看home目录下，nginx 解压后的文件目录名 cd nginx-1.12.0/（解压后的nginx目录，都是一些源码） ./configure，执行该命令配置基础环境（nginx自带的源码） make，编译一下这些nginx源码 make install，安装 nginx（会安装到 /usr/local/…） cd /usr/local进入后，用 ll 命令看是否有 nginx 目录 cd nginx 真正进入到 nginx 目录， 然后 ll看当前目录下的内容 conf html logs sbin pwd，看当前所在的目录路径 cd sbin进入目录，然后 ll看到只有一个 nginx ./nginx 启动 nginx 到此，可以复制服务器的公网 IP 访问，能看到 Nginx 默认显示信息。 3 部署 H5 项目找到刚才 nginx 的安装路径，一般是在 /usr/local/nginx 然后，创建一个目录，用于存放我们的项目，usr/local/nginx/project 复制本地打包出来的H5项目，就是 dist 下的整个 h5 目录，复制进服务器的 project目录下 4 配置 nginx 在 nginx 目录下，有个 conf 配置文件目录 cd conf/，进入配置文件目录， ll后找到 nginx.conf这就是 nginx 的 web 服务配置文件 修改该配置文件的方式 复制到本机，文本方式修改 服务器vim nginx.conf，编辑器打开 123456789101112131415// 1 键盘找到 "server" 配置对象，按 a 键进入编辑模式， 按 esc 退出， :wq 保存退出server &#123; listen:81; // 2 从默认的 80 改成 81，这个要看服务器开启了什么端口 server_name localhost; // 本地&#125;// 3 增加一台服务配置server &#123; listen:80; server_name errorje.cn; // 4 可以配置域名 // 5 配置项目页面路径， 匹配 / 路径 location / &#123; root /usr/local/nginx/movie/h5; // 就是项目的目录。可以在连接服务器工具上复制该路径 index index.html; // 匹配的访问首页 &#125;&#125; 5 重启 nginx 服务器进入 sbin 目录，执行 ./nginx -t测试，来验证当前配置文件是否正确 若配置文件是正确的范阔，则执行重启服务器让配置文件生效 ./nginx -s reload]]></content>
  </entry>
  <entry>
    <title><![CDATA[uni-app框架了解]]></title>
    <url>%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%2Funi-app%E6%A1%86%E6%9E%B6%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[[TOC] 与 vue 的区别不需要引入Vue-router由框架解决。页面创建时，自动将页面路由加入 pages.json 文件中。页面的跳转使用 123uni.navigateTo(&#123; url: 'test?id=1&amp;name=uniapp'&#125;); 生命周期改动相对于 vue 的实例生命周期，uni-app 对程序应用层面和页面层面增加对应的生命周期 12onReady 取代 mountedonLoad 取代 created 箭头函数注意不要在回调上或框架选项属性如 created上使用箭头函数，因为 this 绑定的不是 vue ，是未定义的。 跨平台框架限制H5的vue语法得到全部支持，App 和小程序有功能限制。 data 属性使用函数返回 return 对象 12345data()&#123; return &#123; title:'xx' &#125;&#125; 全局变量有四种方式提供实现 vue 的全局变量 1 公用模块：缺点是每次都需要引入 12345678910111213141516171819// common/helper.js 定义公共方法const websiteUrl = 'http://uniapp.dcloud.io'; export default &#123; websiteUrl, &#125; // pages/index/index.vue 引用模块import helper from '../../common/helper.js'; export default &#123; data() &#123; return &#123;&#125;; &#125;, onLoad()&#123; console.log('now:' + helper.now()); &#125;, methods: &#123; &#125; &#125; 2 挂载 Vue.prototype：扩展Vue 的原型 建议统一加前缀。这样可以与当前页面区分开 1234567891011// main.jsVue.prototype.websiteUrl = 'http://uniapp.dcloud.io'; // 使用&lt;script&gt; export default &#123; onLoad()&#123; console.log('now:' + this.websiteUrl); &#125;, &#125; &lt;/script&gt; 3 gloablData 这是小程序的实现方式 在 App 上声明全局变量，但是在 Vue 中是没有的。可以在 App.vue 的 globalData属性上读写这个值 12345678910// App.vueexport default &#123; globalData: &#123; text: 'text' &#125;, &#125; // 读写方式：可以在页面的 onShow 钩子中进行变量赋值getApp().globalData.text = 'test' // 赋值console.log(getApp().globalData.text) // 'test' 读值 4 Vuex 状态管理模式，集中式存储所有组件状态。需要自己学习 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 1 创建 store 目录和 store.jsconst store = new Vuex.Store(&#123; state: &#123; login: false, token: '', avatarUrl: '', userName: '' &#125;, mutations: &#123; login(state, provider) &#123; console.log(state) console.log(provider) state.login = true; state.token = provider.token; state.userName = provider.userName; state.avatarUrl = provider.avatarUrl; &#125;, logout(state) &#123; state.login = false; state.token = ''; state.userName = ''; state.avatarUrl = ''; &#125; &#125; &#125;) // 2 main.js 挂载 Vueximport store from './store' Vue.prototype.$store = store // 3 pages/index/index.vue 使用import &#123; mapState, mapMutations &#125; from 'vuex'; export default &#123; computed: &#123; ...mapState(['avatarUrl', 'login', 'userName']) &#125;, methods: &#123; ...mapMutations(['logout']) &#125; &#125; class 和 style 动态绑定语法 https://cn.vuejs.org/v2/guide/class-and-style.html 12345678&lt;view :class="&#123; active: isActive &#125;"&gt;111&lt;/view&gt;&lt;view class="static" v-bind:class="&#123; active: isActive, 'text-danger': hasError &#125;"&gt;222&lt;/view&gt;&lt;view class="static" :class="[activeClass, errorClass]"&gt;333&lt;/view&gt;&lt;view class="static" v-bind:class="[isActive ? activeClass : '', errorClass]"&gt;444&lt;/view&gt;&lt;view class="static" v-bind:class="[&#123; active: isActive &#125;, errorClass]"&gt;555&lt;/view&gt;&lt;view v-bind:style="&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"&gt;666&lt;/view&gt;&lt;view v-bind:style="[&#123; color: activeColor, fontSize: fontSize + 'px' &#125;]"&gt;777&lt;/view&gt; v-for 索引和 keyh5 模式从1 开始，其他平台从0开始。 key 最好是唯一标识，如果不写可以选择忽略警告。 事件处理器 支持全 Vue 事件， 绑定事件用 @ 12345678910111213141516171819202122232425262728293031// 事件映射表，左侧为 WEB 事件，右侧为 ``uni-app`` 对应事件&#123; click: 'tap', touchstart: 'touchstart', touchmove: 'touchmove', touchcancel: 'touchcancel', touchend: 'touchend', tap: 'tap', longtap: 'longtap', input: 'input', change: 'change', submit: 'submit', blur: 'blur', focus: 'focus', reset: 'reset', confirm: 'confirm', columnchange: 'columnchange', linechange: 'linechange', error: 'error', scrolltoupper: 'scrolltoupper', scrolltolower: 'scrolltolower', scroll: 'scroll'&#125;// 事件修饰符.stop：全平台支持。组织事件冒泡.prevent.self.once.capture.passive 表单组件替换12select -&gt; pickerradio -&gt; radio-group 非H5端不支持列表1234567Slot（scoped 暂时还没做支持）动态组件异步组件inline-templateX-Templateskeep-alivetransition （可使用 animation 或 CSS 动画替代） 各平台的条件编译 具体取值看文档 5+APP 平台 1234#ifdef APP-PLUSvar appid = plus.runtime.appid;console.log('应用的 appid 为：' + appid);#endif 除了H5 和 微信小程序平台 123#ifndef H5 || MP-WEIXIN需条件编译的代码#endif static 静态目录的处理 12各个平台标识值的小写作为目录，将资源放置其下作为各个平台对应编译获取的静态资源目录若是直接写在 static 目录下的资源，则是全平台可使用 H5 的事件定义扩展 uniapp 没有 document，使用 plus.globalEvent.addEventListener 在 manifest.json 中需要开启新编译器，即自定义组件模式”usingComponents”:true 1234// #ifdef APP-PLUS// 监听设备网络状态变化事件plus.globalEvent.addEventListener('netchange', function()&#123;&#125;);// #endif HTML元素和组件一些标签的变更page 相当于 body， view相当于 div 特定组件（高度不可修改） NavigationBar，导航栏， 44px高度（H5） TabBar，底部选项卡， 50px 容器标签 Template 和 block前者用于条件渲染，后者用于列表渲染 123456789101112&lt;template&gt; &lt;view&gt; &lt;template v-if="test"&gt; &lt;view&gt;test 为 true 时显示&lt;/view&gt; &lt;/template&gt; &lt;template v-else&gt; &lt;block v-for="(item,index) in list" :key="index"&gt; &lt;view&gt;&#123;&#123;item&#125;&#125; - &#123;&#123;index&#125;&#125;&lt;/view&gt; &lt;/block&gt; &lt;/template&gt; &lt;/view&gt;&lt;/template&gt; H5 平台不支持小程序组件若要使用各个小程序平台的自定义组件，就在项目根目录下分别创建对应目录 1234// 小程序组件要放在项目特殊文件夹wxcomponents（或 mycomponents、swancomponents）// wxcomponents文件目录，HBuilder 创建的放在根目录。vue-cli 创建的放在 src 目录 Vue 组件使用三步骤：导入，注册和使用 12345678910111213&lt;template&gt;&lt;view&gt; &lt;uni-rate value=&quot;2&quot;&gt;&lt;/uni-rate&gt; &lt;!-- 第三步，使用组件。并传值点亮2颗星 --&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; import uniRate from &quot;@/components/uni-rate/uni-rate.vue&quot; //第一步，导入组件 export default &#123; components: &#123; uniRate //第二步，注册组件 &#125; &#125;&lt;/script&gt; 全局组件的使用，在 main.js 中注册 1234567891011// main.js 里进行全局导入和注册import Vue from 'vue'import pageHead from './components/page-head.vue'Vue.component('page-head',pageHead)// index.vue 里直接使用组件&lt;template&gt; &lt;view&gt; &lt;page-head&gt;&lt;/page-head&gt; &lt;/view&gt;&lt;/template&gt; 页面样式与布局 因为是跨端，所以推荐完全使用 flex 布局系统 页面尺寸单位使用 rpx基准是 750 px，跟小程序的实现一致。 也可以使用 px，这样就不会随着设备变化 样式的处理样式导入 @import 需要使用相对路径，用 ; 表示语句结束 123&lt;style&gt; @import "../../common/uni.css";&lt;/style&gt; 避免 style 属性动态渲染，影响性能，如 1&lt;view :style="&#123;color:color&#125;" /&gt; 三个CSS全局变量123var(--status-bar-height) 系统状态栏高度var(--window-top) 内容距离顶部距离var(--window-bottom) 图片和icon处理类似 url(file)-loader 的处理 图片小于 40kb， 转为 base64 大于等于 40kb， 要手动转为 base64 ，挪到服务器上用URL引入 本地图片仅支持 ~@语法，绝对路径 网络路径必须加 https（特别是阿里巴巴矢量图库，默认是没有协议头） 1234567.test2 &#123; background-image: url('~@/static/logo.png');&#125;@font-face &#123; font-family: 'iconfont'; src: url('https://at.alicdn.com/t/font_865816_17gjspmmrkti.ttf') format('truetype');&#125; 依赖管理也是支持 Npm 管理的 123456789// 1 npm 初始化项目npm init -y// 2 安装依赖 npm i --save xxx// 3 两种方式引入依赖import package from 'packageName'const package = require('packageName') 业务处理获取上页面回传参数1onLoad(e)&#123;&#125; // 可以打印这个 e 看下内容 设置全局数据和方法——内置了Vuex1234567891011121314151617181920212223//store.jsimport Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const store = new Vuex.Store(&#123; state: &#123;...&#125;, mutations: &#123;...&#125;, actions: &#123;...&#125;&#125;)export default store//main.js...import store from './store'Vue.prototype.$store = storeconst app = new Vue(&#123; store,...&#125;)...//test.vue 使用时：import &#123;mapState,mapMutations&#125; from 'vuex' onError 错误捕获回调 因为这不是严格的生命周期，但是可以在根组件下添加 onError 的回调函数 1234567891011export default &#123; // 只有 app 才会有 onLaunch 的生命周期 onLaunch () &#123; // ... &#125;, // 捕获 app error onError (err) &#123; console.log(err) &#125;&#125; 组件属性设置不生效 记录组件内部变化的值，在设置新值之前先设置为记录的当前值 1234567891011121314151617181920212223export default &#123; data() &#123; return &#123; scrollTop: 0, old: &#123; scrollTop: 0 &#125; &#125; &#125;, methods: &#123; // 保存原有旧数据 scroll: function(e) &#123; this.old.scrollTop = e.detail.scrollTop &#125;, // 回到 0 goTop: function(e) &#123; this.scrollTop = this.old.scrollTop this.$nextTick(function() &#123; this.scrollTop = 0 &#125;); &#125; &#125;&#125;]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>uni-app</tag>
        <tag>小程序</tag>
        <tag>跨端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo主题使用细节]]></title>
    <url>%2F%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%2Fhexo%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[Hexo 文档实际上还是不够详细。这里列出一些调整的经验和细节。 除了官方文档，推荐阅读一个关于 Next 主题总结比较好的博客 https://hexo-guide.readthedocs.io/zh_CN/latest/index.html https://www.jianshu.com/p/efbeddc5eb19 布局样式设置首页文章展示数量在站点的配置文件中设置 1234index_generator: path: '' per_page: 1 order_by: -date 标签/分类也是同理 1234567archive_generator: per_page: 20 yearly: true monthly: truetag_generator: per_page: 10 设置首页文章阅读全文有三种方式，但是注意不能同时使用，可能出现设置无效的情况 文章内容中插入标记表示截断 推荐的方式 1&lt;!-- more --&gt; 文章头部信息中配置描述 大概能显示几段内容 1front-matter:description 自动形成摘要，配置主题文件 限定了内容字数，如果字数特别少的话，需要配首页文章显示数量以达到比较好的效果。 如果使用 md 语法，则会解析成字符串，所以不推荐这种方式 123auto_excerpt: enable: true length: 150 设置更新时间需要去主题配置文件中开启更新日期记录 12345post_meta: item_text: true created_at: true updated_at: true categories: true 另外时间的格式没有要求 12018-09-08 和 2018年9月8日 效果是一样的 主页文章增加边框阴影 打开 themes/next/source/css/_custom/custom.styl ,向里面加代码: 12345678// 主页文章添加阴影效果.post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 页面加载条和文章阅读进度修改主题配置文件 123scrollpercent: true # 文章进度pace: true # 加载条pace_theme: pace-theme-flash # 加载条主题 文字数量统计和阅读时间估算博客根目录下安装插件 npm i --save hexo-wordcount 再配置主题文件 123456789post_wordcount: item_text: true # 字数统计 wordcount: true # 预览时间 min2read: true # 总字数，显示页面底部 totalcount: true separated_meta: true 修改文章访问 URL配置站点文件 1permalink: :category/:title/ 插件功能访客统计利用三方脚本“不蒜子”，只需要两步 在 footer.swig 文件中引入 Script（关注官网提供的CDN是否改变） 12&lt;script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 在 footer.swig 任意处添加显示人数统计的标签 pv，算访问次数 uv，算访客人数 1234&lt;span class="post-meta-divider"&gt;|&lt;/span&gt;&lt;span id="busuanzi_container_site_uv"&gt; 本站访客数：&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt; 人次&lt;/span&gt; 文章阅读次数这和访客数是一样的原理。通过配置“不蒜子”来达到显示次数的目的。 好在 Next 主题在其配置文件, _config.yml 提供了包括“不蒜子”在内的插件配置。 只要开启和自定义文字内容就行了 123456789101112131415161718192021# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/# 不蒜子访客统计配置busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site # 整个站点的 uv（访客统计） site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt; 本站访客数&lt;/i&gt; site_uv_footer: &lt;i&gt; 人&lt;/i&gt; # custom pv span for the whole site # 整个站点的 pv（访问统计） site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt; 本站阅读量&lt;/i&gt; site_pv_footer: &lt;i&gt; 次&lt;/i&gt; # custom pv span for one page only # 文章阅读量配置 page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;已阅读&lt;/i&gt; page_pv_footer: &lt;i&gt; 次&lt;/i&gt; 这里有个细节要注意，就是不蒜子在官网也说了，更换了 CDN 地址。而在 Next 自带的不蒜子 CDN 配置中还是老的，所以会出现访客记录不显示的问题。找到文件 /theme/next/layout/_third-party/analytics/busuanzi-counter.swig文件 替换 CDN 地址 1&lt;script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 还有个细节，Next 既然都自带了不蒜子的所有统计功能，所以就不要按第一种方式显示了。不然会冲突。 评论功能使用的是 github App，载体是某个仓库的 issue。 step1：创建新的 github 应用 这个也是用于第三方登录认证用的 按照要求填写，应用名（随意）、主页（博客网址）、描述、网址（博客网址）。 创建成功后，github 会提供 Client ID 和 Client Secret两个密钥 step2：配置 Next找到主题配置文件 _config.yml，老版本搜“gitalk”，新版本搜“gitment” 1234567891011121314gitment: # 开启 git issue 评论 enable: true # 需要开启 mint: true count: true lazy: false # 点击按钮后才显示评论控件 cleanly: true # 隐藏一些控件自带的广告信息 language: github_user: # github 账号 github_repo: # github 某个仓库名，最终评论存在于 Issue client_id: # 创建应用时提供的 client_secret: # 创建应用时提供的 proxy_gateway: redirect_protocol: 若在评论框控件中出现了报错， 可以尝试换个仓库 step3：关闭某页面的评论 比如分类/标签页面，他们本质上也是一个 md 文件。找到他们后也是在文件头部设置关闭评论 12345title: All tagsdate: 2015-12-16 17:05:24type: "tags"comments: false # 这个地方给他关了--- 搜索功能简单的方式就是实现本站点本地搜索。 step1：博客根目录下安装插件npm install hexo-generator-searchdb --save step2：配置站点文件本身配置文件是没有这些内容的，安装完插件后需要手动添加 12345search: path: search.xml field: post format: html limit: 10000 step3：配置主题文件开启一下就好 123# Local searchlocal_search: enable: true 细节调整页面 Footer 文字更改首先找到一个模板渲染文件和存放中文的语言配置文件。 12- \themes\next\layout\_partials\下面的footer.swig文件- \themes\next\languages\ 下面的语言文件zh-Hans.yml 第一个文件，对应了底部的几个部分（默认情况下） 第一行文字后面的作者名 第二行左半边“由xxx强力驱动” 第二行右半边“next版本” 这里是对第二个文件的配置变量做了一个引用。 对于上图中的链接，就是以 a 标签形式存在。 第一个框，可以不改，因为就显示作者信息 第二个框。将引号内的 a 标签去除（保留引号） 第三个框。a 标签全部去除 如果要更改对应变量的文字，则去第二个文件中重新配置。]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RequireJS 基本配置]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%2Frequirejs%20%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[AMD - require 配置函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* AMD - require 配置函数*/require.config(&#123; // 公共路径 baseUrl: '/xxx/xxx', // 插件库的映射字典 paths: &#123; 'jQuery': [ // 每个插件或库的路径，使用的时候可以直接使用其key的部分来代替路径引入 'cnd:/xxxxx', // 数组形式value值，第一个无法加载时，执行第二个 'lib/xx/xxx' // 可以省略 js 后缀 ] &#125;, /*解决非AMD规范的js时， 解决其载入顺序 有很多的插件和库并不是完全符合模块化规范 */ shim: &#123; 'easyui': &#123; // 表明还需要依赖哪些模块 deps: [ 'jquery', // 对CSS路径的引用 css! 'css!lib/easyui-1.5.1/themes/metro-blue-ext/easyui.css', 'css!lib/easyui-1.5.1/themes/icon.css' ], // 输出的变量名 exports: 'jQuery' &#125;, &#125;, // 对不同文件前缀给不同的模块 map: &#123; // 在some模块使用 foo 的时候，会使用不同的版本 'some1': &#123; 'foo': 'foov1' &#125;, 'some2': &#123; 'foo': 'foov2' &#125;, // 对所有模块都使用这个版本 '*': &#123; 'css': 'lib/require-css/0.1.8/css.min' &#125; &#125;, // 其他情况下需要用到变量和方法的 config: &#123; // 这里的bar实际上是模块的名字，xxxx/bar.js 'bar': &#123; size: 'large' &#125; /* 对应的调用方式， 在对应模块下， 这里 bar.js define(function (require, exports, module) &#123; var size = module.config().size &#125;) 第二种方式 define(['module'], function (module) &#123; var size = module.config().size &#125;) */ &#125;&#125;) AMD - require 模块定义12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* AMD - require 模块定义*/// 1 简单的键值对define(&#123; color: 'black', size: 'unsize'&#125;)// 2 函数式定义define(function () &#123; // ...初始化... var xxx = (function () &#123; return &#123; xxx1: function() &#123;&#125;, xxx2: function() &#123;&#125;, &#125; &#125;)() return xxx&#125;)// 3 存在依赖函数式define(['xx1', 'xx2'], function (xx1, xx2) &#123; var bomm = function() &#123;&#125; return bomm // 返回一个对象&#125;)// 4 模块定义为一个函数define(['xx1', 'xx2'], function(xx1, xx2) &#123; return function (e) &#123;&#125;&#125;)// 5 包装CommonJS定义模块define(function(require, exports, module) &#123; var a = require('a'), b = require('b') return function()&#123;&#125;&#125;)// 6 定义命名模块define('name', ['xx1', 'xx2'], function(xx1, xx2) &#123; // ....&#125;)]]></content>
      <categories>
        <category>前端模块化</category>
      </categories>
      <tags>
        <tag>AMD</tag>
        <tag>requirejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Funcategorized%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建博客]]></title>
    <url>%2F%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%2Fhexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[现在搭建博客是越来越方便了，一直想找个快速搭建博客的工具。现在记录一下hexo的使用和踩过的一些坑。希望对新手有所帮助。 搭建之前的环境准备安装 Git官网下载 git 安装包，然后进行安装。 git bash 是一个命令行工具，用来操作和仓库有关的行为。 SSH 连接远程库 当前前提是需要拥有 github 的账号 注册github账户具体步骤很简单，不会可百度 创建 github 项目新建一个项目，然后仓库的名字必须是 xxx.github.io， 这也是之后访问的 URL。 到项目的设置里，去测试一下。 点击 setting，拉到下面有个 github pages， 单击 choose a theme选择主题。选择好以后，返回，然后点击xxx.github.io链接，就能看到博客页面了。 SSH授权通过 SSH 从本地同步连接到 githun 服务器。 打开git bash， 输入 ssh-keygen -t rsa，回车3下 这样就会在 C 盘用户目录下的.ssh目录下生成 id_rsa 和 id_rsa.pub两个文件。 前者是私钥，后者是公钥。 私钥，证明自己身份。 公钥，是给出去的。 用 txt 方式打开公钥id_rsa.pub，复制全部内容，添加到 Github 上。 这样本地的密钥id_rsa和 Github 上的公钥 id_rsa.pub进行配对。 在 Github 上，进入自己的 Setting 然后点击左侧的 SSH and GPG keys，然后添加一个 New SSH key，将公钥内容复制进去保存。 最后打开 git bash 输入 ssh -T git@github.com 进行授权测试。 若返回“hi xxxx You’ve successfullly….” 说明是授权成功的。 github desktop但是现在有更好的方式，不用使用这种传统使用命令行的方式了。就是下载 github的客户端版本,github desktop。 到 hexo 中执行博客提交命令时，一般会验证 SSH。现在有了这个只要一次登录就行了。 tortoisegit也是可视化操作 github 命令的。但是没有 desktop 现代 安装 Nodenode 安装，直接去官网下载一个。安装好之后，打开 Cmd 命令行，输入 node -v 检查下是否成功。 安装 Hexo 和初始化安装 Hexo 脚手架npm i -g hexo-cli，作为脚手架工具，相比之后会经常用到，所以安装到全局。 初始化博客本地目录 这里有个坑，之前创建的 github 项目，仅仅是作为特殊的博客载体。无需 clone 到本地。 我们会在本地写文章，然后本地启动 hexo 服务器查看静态页是怎样的，最后通过配置文件去指定上面的仓库URL，并获取权限。然后通过 hexo 一键部署到上面。 123hexo init xxx // 新建一个目录，作为 hexo 管理的博客项目。cd xxx // 进入这个目录npm i // 安装必要的依赖 Hexo 项目目录12345678├── _config.yml 配置文件├── package.json 依赖配置文件├── scaffolds 模板文件，每次新建 md 文章，都会去应用。默认就3个post等├── source 用户资源目录| ├── _drafts| └── _posts 文章所在地└── themes 主题选定。下载或者clone的主题包放这里。├── public 最后经过 Hexo 解析，被部署到 github 分支上的目录 开始 hello world基本配置不不管网站的内容，先从基本的网站配置开始。 配置文件，_config.yml。大部分的功能实现，都是基于这个配置 下面列出几个模块的配置项 网站 Site12345678# Sitetitle: ErrorJE's Blogsubtitle: ErrorJE 学习记录分享 (主要用于SEO)description: ErrorJE 前端技术keywords: ErrorJE 前端 架构师 全栈author: ErrorJElanguage: zhtimezone:（时区的名字） 网址 URL1基本没用。若博客放在子目录的，就需要指定下目录 目录 Directory1暂时不修改。主要是一些资源存放的目录设定 文章 Writing123456789101112131415new_post_name: :title.md # 新文章的文件名 # 可以使用 :year-:month-:day-:title.md 的格式，更方便管理default_layout: post # 默认布局titlecase: false # 转换 titleexternal_link: true # 新标签页中打开链接filename_case: 0render_drafts: falsepost_asset_folder: false # true时，每个文章顺带一个同名放资源的文件夹relative_link: false # 将链接改为根目录的相对地址future: true # 显示未来的文章highlight: # 代码块设置 enable: true line_number: true auto_detect: false tab_replace: 类和标签 Category &amp; Tag 在文章的头部信息中去配置不同的分类和标签 123456categories:- 前端- 工具tags:- 工具教程- 踩坑经验 日期/时间格式 Date / Time format 使用 moment.js 来解析时间 12date_format: YYYY-MM-DDtime_format: HH:mm:ss 分页 Pagination12per_page: 10 # 每页文章量（0位关闭分页功能）pagination_dir: page # 分页目录 扩展 Extensions 主题和部署地址123456theme: landscape # 当前主题名称deploy: # 部署部分 type: git # 使用 git 方式 repo: https://github.com/ErrorJe/ErrorJE.github.io # 承载博客的仓库地址 branch: [branch] # 分支名称。不写的话默认是 master 主分支 message: [message] # 非必需 基本命令初始化博客目录hexo init xxxx，新建一个名为 xxxx 的目录作为博客项目目录 新建文章hexo new 布局(默认 post) xxx，新建后的文章名为 xxx.md 若文件名有空格，则用引号包裹起来。 布局的区别 默认有3种，仅仅是写了基础信息的模板而已。在 scaffolds目录下 post 直接可以发布的文章 page draft，草稿。后期需要 publish 才可以部署 生成静态文件hexo g，还有两种选择 hexo g - d， 生成文件后立即部署网站 hexo g -w，监视文件变动 生成草稿 该步骤非必需 hexo publish 布局 文件名 启动本地服务测试 必须先安装依赖， npm i --S hexo-server。之后修改文章会自动更新服务。 hexo server，这是启动本地服务，可以看下效果。还有3个选项 hexo s -p xxxx， 重新设定端口号 hexo s -s 只使用静态文件 hexo s -l，启动日志记录，使用覆盖记录格式 部署网站hexo d一键部署。 如果不是用hexo-cli的话，这一步还需要安装 npm i -S hexo-deployer-git，用于发布博客到 git 的 Npm 包。 若报错没有找到 git ，也是因为没有安装这个依赖。 执行这个命令后，会让你登录 github 清除缓存和静态文件hexo clean，有时候更换主题没有变化，就需要清理缓存文件 db.json 和静态文件 public 开始写作实际写作时的步骤 hexo new post xxxx创建有基本信息填充的md文件 复制自己写好的 md 内容，然后根据需要修改头部文章基本信息 hexo g -d生成静态文件后直接部署 也可以本地调试 hexo g生成静态文件 hexo server本地测试 hexo d发布部署 更换主题的话可能还需要执行 hexo clean来清除缓存 创建文章文件hexo new 布局(默认 post) xxx，会在 .md 头部增加文章基本信息。 该文件会出现在 source/_posts，平时写作也就关心这个文件夹就行了。 文章的变量信息 Front-matter这是显示在每篇文章最上面，使用分割线区别文章内容，以表示文章基本信息的变量 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 资源文件在根目录下的 source 中，除了放文章，还可以把其他静态资源放进来。 但是注意，最大是300M。比如创建一个图片目录images，像下面一样使用。 虽然现在还没有显示，但是最后部署后，就是能访问到 当然也可以在配置文件中去设置，每次新建文件的时候，一起把同名的静态资源目录也生成。最后就能使用下面这样的方式，让网页和md文件都能看到图片。 1&#123;% asset_img example.jpg This is an example image %&#125; 其他自定义配置绑定域名 买个域名 去解析一下域名的 xxx.github.io，类型选择cname githun的仓库设置，去custom domain填入这个域名 若本地没有用的话，去 source目录新建CNAME文件，没有后缀，内容写域名 选择主题基本上一个博客，就是基于一个主题的。这里推荐 beantech。 切换主题下面3个步骤就可以搭建主题博客。 先找到这个主题的 github 地址 然后 clone 到博客项目的 theme 目录下 去博客根目录下， 配置 _config.yml，去extensions中找 theme 配置该主题名 主题初始化上面是在原有博客项目的基础上，去切换主题。 下面这种方式是，先有主题，然后再去写博客。 123git clone https://github.com/YenYuHsuan/hexo-theme-beantech.git ./hexo-beantechcd hexo-beantechnpm install 然后自定义配置文件等等。 推荐主题 NexThttps://theme-next.iissnan.com/getting-started.html 有中文文档，也是目前 star 最多的主题。 利用 Github 搭建图床在自己的博客git上创建一个个 issues，然后直接把图片拉进去就完事了。 然后找到该图片的 URL 地址，最后在自己的博客里用]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
