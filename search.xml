<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[uni-app框架了解]]></title>
    <url>%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%2Funi-app%E6%A1%86%E6%9E%B6%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[[TOC] 与 vue 的区别不需要引入Vue-router由框架解决。页面创建时，自动将页面路由加入 pages.json 文件中。页面的跳转使用 123uni.navigateTo(&#123; url: 'test?id=1&amp;name=uniapp'&#125;); 生命周期改动相对于 vue 的实例生命周期，uni-app 对程序应用层面和页面层面增加对应的生命周期 12onReady 取代 mountedonLoad 取代 created 箭头函数注意不要在回调上或框架选项属性如 created上使用箭头函数，因为 this 绑定的不是 vue ，是未定义的。 跨平台框架限制H5的vue语法得到全部支持，App 和小程序有功能限制。 data 属性使用函数返回 return 对象 12345data()&#123; return &#123; title:'xx' &#125;&#125; 全局变量有四种方式提供实现 vue 的全局变量 1 公用模块：缺点是每次都需要引入 12345678910111213141516171819// common/helper.js 定义公共方法const websiteUrl = 'http://uniapp.dcloud.io'; export default &#123; websiteUrl, &#125; // pages/index/index.vue 引用模块import helper from '../../common/helper.js'; export default &#123; data() &#123; return &#123;&#125;; &#125;, onLoad()&#123; console.log('now:' + helper.now()); &#125;, methods: &#123; &#125; &#125; 2 挂载 Vue.prototype：扩展Vue 的原型 建议统一加前缀。这样可以与当前页面区分开 1234567891011// main.jsVue.prototype.websiteUrl = 'http://uniapp.dcloud.io'; // 使用&lt;script&gt; export default &#123; onLoad()&#123; console.log('now:' + this.websiteUrl); &#125;, &#125; &lt;/script&gt; 3 gloablData 这是小程序的实现方式 在 App 上声明全局变量，但是在 Vue 中是没有的。可以在 App.vue 的 globalData属性上读写这个值 12345678910// App.vueexport default &#123; globalData: &#123; text: 'text' &#125;, &#125; // 读写方式：可以在页面的 onShow 钩子中进行变量赋值getApp().globalData.text = 'test' // 赋值console.log(getApp().globalData.text) // 'test' 读值 4 Vuex 状态管理模式，集中式存储所有组件状态。需要自己学习 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 1 创建 store 目录和 store.jsconst store = new Vuex.Store(&#123; state: &#123; login: false, token: '', avatarUrl: '', userName: '' &#125;, mutations: &#123; login(state, provider) &#123; console.log(state) console.log(provider) state.login = true; state.token = provider.token; state.userName = provider.userName; state.avatarUrl = provider.avatarUrl; &#125;, logout(state) &#123; state.login = false; state.token = ''; state.userName = ''; state.avatarUrl = ''; &#125; &#125; &#125;) // 2 main.js 挂载 Vueximport store from './store' Vue.prototype.$store = store // 3 pages/index/index.vue 使用import &#123; mapState, mapMutations &#125; from 'vuex'; export default &#123; computed: &#123; ...mapState(['avatarUrl', 'login', 'userName']) &#125;, methods: &#123; ...mapMutations(['logout']) &#125; &#125; class 和 style 动态绑定语法 https://cn.vuejs.org/v2/guide/class-and-style.html 12345678&lt;view :class="&#123; active: isActive &#125;"&gt;111&lt;/view&gt;&lt;view class="static" v-bind:class="&#123; active: isActive, 'text-danger': hasError &#125;"&gt;222&lt;/view&gt;&lt;view class="static" :class="[activeClass, errorClass]"&gt;333&lt;/view&gt;&lt;view class="static" v-bind:class="[isActive ? activeClass : '', errorClass]"&gt;444&lt;/view&gt;&lt;view class="static" v-bind:class="[&#123; active: isActive &#125;, errorClass]"&gt;555&lt;/view&gt;&lt;view v-bind:style="&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"&gt;666&lt;/view&gt;&lt;view v-bind:style="[&#123; color: activeColor, fontSize: fontSize + 'px' &#125;]"&gt;777&lt;/view&gt; v-for 索引和 keyh5 模式从1 开始，其他平台从0开始。 key 最好是唯一标识，如果不写可以选择忽略警告。 事件处理器 支持全 Vue 事件， 绑定事件用 @ 12345678910111213141516171819202122232425262728293031// 事件映射表，左侧为 WEB 事件，右侧为 ``uni-app`` 对应事件&#123; click: 'tap', touchstart: 'touchstart', touchmove: 'touchmove', touchcancel: 'touchcancel', touchend: 'touchend', tap: 'tap', longtap: 'longtap', input: 'input', change: 'change', submit: 'submit', blur: 'blur', focus: 'focus', reset: 'reset', confirm: 'confirm', columnchange: 'columnchange', linechange: 'linechange', error: 'error', scrolltoupper: 'scrolltoupper', scrolltolower: 'scrolltolower', scroll: 'scroll'&#125;// 事件修饰符.stop：全平台支持。组织事件冒泡.prevent.self.once.capture.passive 表单组件替换12select -&gt; pickerradio -&gt; radio-group 非H5端不支持列表1234567Slot（scoped 暂时还没做支持）动态组件异步组件inline-templateX-Templateskeep-alivetransition （可使用 animation 或 CSS 动画替代） 各平台的条件编译 具体取值看文档 5+APP 平台 1234#ifdef APP-PLUSvar appid = plus.runtime.appid;console.log('应用的 appid 为：' + appid);#endif 除了H5 和 微信小程序平台 123#ifndef H5 || MP-WEIXIN需条件编译的代码#endif static 静态目录的处理 12各个平台标识值的小写作为目录，将资源放置其下作为各个平台对应编译获取的静态资源目录若是直接写在 static 目录下的资源，则是全平台可使用 H5 的事件定义扩展 uniapp 没有 document，使用 plus.globalEvent.addEventListener 在 manifest.json 中需要开启新编译器，即自定义组件模式”usingComponents”:true 1234// #ifdef APP-PLUS// 监听设备网络状态变化事件plus.globalEvent.addEventListener('netchange', function()&#123;&#125;);// #endif HTML元素和组件一些标签的变更page 相当于 body， view相当于 div 特定组件（高度不可修改） NavigationBar，导航栏， 44px高度（H5） TabBar，底部选项卡， 50px 容器标签 Template 和 block前者用于条件渲染，后者用于列表渲染 123456789101112&lt;template&gt; &lt;view&gt; &lt;template v-if="test"&gt; &lt;view&gt;test 为 true 时显示&lt;/view&gt; &lt;/template&gt; &lt;template v-else&gt; &lt;block v-for="(item,index) in list" :key="index"&gt; &lt;view&gt;&#123;&#123;item&#125;&#125; - &#123;&#123;index&#125;&#125;&lt;/view&gt; &lt;/block&gt; &lt;/template&gt; &lt;/view&gt;&lt;/template&gt; H5 平台不支持小程序组件若要使用各个小程序平台的自定义组件，就在项目根目录下分别创建对应目录 1234// 小程序组件要放在项目特殊文件夹wxcomponents（或 mycomponents、swancomponents）// wxcomponents文件目录，HBuilder 创建的放在根目录。vue-cli 创建的放在 src 目录 Vue 组件使用三步骤：导入，注册和使用 12345678910111213&lt;template&gt;&lt;view&gt; &lt;uni-rate value=&quot;2&quot;&gt;&lt;/uni-rate&gt; &lt;!-- 第三步，使用组件。并传值点亮2颗星 --&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; import uniRate from &quot;@/components/uni-rate/uni-rate.vue&quot; //第一步，导入组件 export default &#123; components: &#123; uniRate //第二步，注册组件 &#125; &#125;&lt;/script&gt; 全局组件的使用，在 main.js 中注册 1234567891011// main.js 里进行全局导入和注册import Vue from 'vue'import pageHead from './components/page-head.vue'Vue.component('page-head',pageHead)// index.vue 里直接使用组件&lt;template&gt; &lt;view&gt; &lt;page-head&gt;&lt;/page-head&gt; &lt;/view&gt;&lt;/template&gt; 页面样式与布局 因为是跨端，所以推荐完全使用 flex 布局系统 页面尺寸单位使用 rpx基准是 750 px，跟小程序的实现一致。 也可以使用 px，这样就不会随着设备变化 样式的处理样式导入 @import 需要使用相对路径，用 ; 表示语句结束 123&lt;style&gt; @import "../../common/uni.css";&lt;/style&gt; 避免 style 属性动态渲染，影响性能，如 1&lt;view :style="&#123;color:color&#125;" /&gt; 三个CSS全局变量123var(--status-bar-height) 系统状态栏高度var(--window-top) 内容距离顶部距离var(--window-bottom) 图片和icon处理类似 url(file)-loader 的处理 图片小于 40kb， 转为 base64 大于等于 40kb， 要手动转为 base64 ，挪到服务器上用URL引入 本地图片仅支持 ~@语法，绝对路径 网络路径必须加 https（特别是阿里巴巴矢量图库，默认是没有协议头） 1234567.test2 &#123; background-image: url('~@/static/logo.png');&#125;@font-face &#123; font-family: 'iconfont'; src: url('https://at.alicdn.com/t/font_865816_17gjspmmrkti.ttf') format('truetype');&#125; 依赖管理也是支持 Npm 管理的 123456789// 1 npm 初始化项目npm init -y// 2 安装依赖 npm i --save xxx// 3 两种方式引入依赖import package from 'packageName'const package = require('packageName') 业务处理获取上页面回传参数1onLoad(e)&#123;&#125; // 可以打印这个 e 看下内容 设置全局数据和方法——内置了Vuex1234567891011121314151617181920212223//store.jsimport Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const store = new Vuex.Store(&#123; state: &#123;...&#125;, mutations: &#123;...&#125;, actions: &#123;...&#125;&#125;)export default store//main.js...import store from './store'Vue.prototype.$store = storeconst app = new Vue(&#123; store,...&#125;)...//test.vue 使用时：import &#123;mapState,mapMutations&#125; from 'vuex' onError 错误捕获回调 因为这不是严格的生命周期，但是可以在根组件下添加 onError 的回调函数 1234567891011export default &#123; // 只有 app 才会有 onLaunch 的生命周期 onLaunch () &#123; // ... &#125;, // 捕获 app error onError (err) &#123; console.log(err) &#125;&#125; 组件属性设置不生效 记录组件内部变化的值，在设置新值之前先设置为记录的当前值 1234567891011121314151617181920212223export default &#123; data() &#123; return &#123; scrollTop: 0, old: &#123; scrollTop: 0 &#125; &#125; &#125;, methods: &#123; // 保存原有旧数据 scroll: function(e) &#123; this.old.scrollTop = e.detail.scrollTop &#125;, // 回到 0 goTop: function(e) &#123; this.scrollTop = this.old.scrollTop this.$nextTick(function() &#123; this.scrollTop = 0 &#125;); &#125; &#125;&#125;]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>uni-app</tag>
        <tag>小程序</tag>
        <tag>跨端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo主题使用细节]]></title>
    <url>%2F%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%2Fhexo%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[Hexo 文档实际上还是不够详细。这里列出一些调整的经验和细节。 除了官方文档，推荐阅读一个关于 Next 主题总结比较好的博客 https://hexo-guide.readthedocs.io/zh_CN/latest/index.html https://www.jianshu.com/p/efbeddc5eb19 布局样式设置首页文章展示数量在站点的配置文件中设置 1234index_generator: path: '' per_page: 1 order_by: -date 标签/分类也是同理 1234567archive_generator: per_page: 20 yearly: true monthly: truetag_generator: per_page: 10 设置首页文章阅读全文有三种方式，但是注意不能同时使用，可能出现设置无效的情况 文章内容中插入标记表示截断 推荐的方式 1&lt;!-- more --&gt; 文章头部信息中配置描述 大概能显示几段内容 1front-matter:description 自动形成摘要，配置主题文件 限定了内容字数，如果字数特别少的话，需要配首页文章显示数量以达到比较好的效果。 如果使用 md 语法，则会解析成字符串，所以不推荐这种方式 123auto_excerpt: enable: true length: 150 设置更新时间需要去主题配置文件中开启更新日期记录 12345post_meta: item_text: true created_at: true updated_at: true categories: true 另外时间的格式没有要求 12018-09-08 和 2018年9月8日 效果是一样的 主页文章增加边框阴影 打开 themes/next/source/css/_custom/custom.styl ,向里面加代码: 12345678// 主页文章添加阴影效果.post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 页面加载条和文章阅读进度修改主题配置文件 123scrollpercent: true # 文章进度pace: true # 加载条pace_theme: pace-theme-flash # 加载条主题 文字数量统计和阅读时间估算博客根目录下安装插件 npm i --save hexo-wordcount 再配置主题文件 123456789post_wordcount: item_text: true # 字数统计 wordcount: true # 预览时间 min2read: true # 总字数，显示页面底部 totalcount: true separated_meta: true 修改文章访问 URL配置站点文件 1permalink: :category/:title/ 插件功能访客统计利用三方脚本“不蒜子”，只需要两步 在 footer.swig 文件中引入 Script（关注官网提供的CDN是否改变） 12&lt;script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 在 footer.swig 任意处添加显示人数统计的标签 pv，算访问次数 uv，算访客人数 1234&lt;span class="post-meta-divider"&gt;|&lt;/span&gt;&lt;span id="busuanzi_container_site_uv"&gt; 本站访客数：&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt; 人次&lt;/span&gt; 文章阅读次数这和访客数是一样的原理。通过配置“不蒜子”来达到显示次数的目的。 好在 Next 主题在其配置文件, _config.yml 提供了包括“不蒜子”在内的插件配置。 只要开启和自定义文字内容就行了 123456789101112131415161718192021# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/# 不蒜子访客统计配置busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site # 整个站点的 uv（访客统计） site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt; 本站访客数&lt;/i&gt; site_uv_footer: &lt;i&gt; 人&lt;/i&gt; # custom pv span for the whole site # 整个站点的 pv（访问统计） site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt; 本站阅读量&lt;/i&gt; site_pv_footer: &lt;i&gt; 次&lt;/i&gt; # custom pv span for one page only # 文章阅读量配置 page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;已阅读&lt;/i&gt; page_pv_footer: &lt;i&gt; 次&lt;/i&gt; 这里有个细节要注意，就是不蒜子在官网也说了，更换了 CDN 地址。而在 Next 自带的不蒜子 CDN 配置中还是老的，所以会出现访客记录不显示的问题。找到文件 /theme/next/layout/_third-party/analytics/busuanzi-counter.swig文件 替换 CDN 地址 1&lt;script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 还有个细节，Next 既然都自带了不蒜子的所有统计功能，所以就不要按第一种方式显示了。不然会冲突。 评论功能使用的是 github App，载体是某个仓库的 issue。 step1：创建新的 github 应用 这个也是用于第三方登录认证用的 按照要求填写，应用名（随意）、主页（博客网址）、描述、网址（博客网址）。 创建成功后，github 会提供 Client ID 和 Client Secret两个密钥 step2：配置 Next找到主题配置文件 _config.yml，老版本搜“gitalk”，新版本搜“gitment” 1234567891011121314gitment: # 开启 git issue 评论 enable: true # 需要开启 mint: true count: true lazy: false # 点击按钮后才显示评论控件 cleanly: true # 隐藏一些控件自带的广告信息 language: github_user: # github 账号 github_repo: # github 某个仓库名，最终评论存在于 Issue client_id: # 创建应用时提供的 client_secret: # 创建应用时提供的 proxy_gateway: redirect_protocol: 若在评论框控件中出现了报错， 可以尝试换个仓库 step3：关闭某页面的评论 比如分类/标签页面，他们本质上也是一个 md 文件。找到他们后也是在文件头部设置关闭评论 12345title: All tagsdate: 2015-12-16 17:05:24type: "tags"comments: false # 这个地方给他关了--- 搜索功能简单的方式就是实现本站点本地搜索。 step1：博客根目录下安装插件npm install hexo-generator-searchdb --save step2：配置站点文件本身配置文件是没有这些内容的，安装完插件后需要手动添加 12345search: path: search.xml field: post format: html limit: 10000 step3：配置主题文件开启一下就好 123# Local searchlocal_search: enable: true 细节调整页面 Footer 文字更改首先找到一个模板渲染文件和存放中文的语言配置文件。 12- \themes\next\layout\_partials\下面的footer.swig文件- \themes\next\languages\ 下面的语言文件zh-Hans.yml 第一个文件，对应了底部的几个部分（默认情况下） 第一行文字后面的作者名 第二行左半边“由xxx强力驱动” 第二行右半边“next版本” 这里是对第二个文件的配置变量做了一个引用。 对于上图中的链接，就是以 a 标签形式存在。 第一个框，可以不改，因为就显示作者信息 第二个框。将引号内的 a 标签去除（保留引号） 第三个框。a 标签全部去除 如果要更改对应变量的文字，则去第二个文件中重新配置。]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RequireJS 基本配置]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%2Frequirejs%20%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[AMD - require 配置函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* AMD - require 配置函数*/require.config(&#123; // 公共路径 baseUrl: '/xxx/xxx', // 插件库的映射字典 paths: &#123; 'jQuery': [ // 每个插件或库的路径，使用的时候可以直接使用其key的部分来代替路径引入 'cnd:/xxxxx', // 数组形式value值，第一个无法加载时，执行第二个 'lib/xx/xxx' // 可以省略 js 后缀 ] &#125;, /*解决非AMD规范的js时， 解决其载入顺序 有很多的插件和库并不是完全符合模块化规范 */ shim: &#123; 'easyui': &#123; // 表明还需要依赖哪些模块 deps: [ 'jquery', // 对CSS路径的引用 css! 'css!lib/easyui-1.5.1/themes/metro-blue-ext/easyui.css', 'css!lib/easyui-1.5.1/themes/icon.css' ], // 输出的变量名 exports: 'jQuery' &#125;, &#125;, // 对不同文件前缀给不同的模块 map: &#123; // 在some模块使用 foo 的时候，会使用不同的版本 'some1': &#123; 'foo': 'foov1' &#125;, 'some2': &#123; 'foo': 'foov2' &#125;, // 对所有模块都使用这个版本 '*': &#123; 'css': 'lib/require-css/0.1.8/css.min' &#125; &#125;, // 其他情况下需要用到变量和方法的 config: &#123; // 这里的bar实际上是模块的名字，xxxx/bar.js 'bar': &#123; size: 'large' &#125; /* 对应的调用方式， 在对应模块下， 这里 bar.js define(function (require, exports, module) &#123; var size = module.config().size &#125;) 第二种方式 define(['module'], function (module) &#123; var size = module.config().size &#125;) */ &#125;&#125;) AMD - require 模块定义12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* AMD - require 模块定义*/// 1 简单的键值对define(&#123; color: 'black', size: 'unsize'&#125;)// 2 函数式定义define(function () &#123; // ...初始化... var xxx = (function () &#123; return &#123; xxx1: function() &#123;&#125;, xxx2: function() &#123;&#125;, &#125; &#125;)() return xxx&#125;)// 3 存在依赖函数式define(['xx1', 'xx2'], function (xx1, xx2) &#123; var bomm = function() &#123;&#125; return bomm // 返回一个对象&#125;)// 4 模块定义为一个函数define(['xx1', 'xx2'], function(xx1, xx2) &#123; return function (e) &#123;&#125;&#125;)// 5 包装CommonJS定义模块define(function(require, exports, module) &#123; var a = require('a'), b = require('b') return function()&#123;&#125;&#125;)// 6 定义命名模块define('name', ['xx1', 'xx2'], function(xx1, xx2) &#123; // ....&#125;)]]></content>
      <categories>
        <category>前端模块化</category>
      </categories>
      <tags>
        <tag>AMD</tag>
        <tag>requirejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Funcategorized%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建博客]]></title>
    <url>%2F%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%2Fhexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[现在搭建博客是越来越方便了，一直想找个快速搭建博客的工具。现在记录一下hexo的使用和踩过的一些坑。希望对新手有所帮助。 搭建之前的环境准备安装 Git官网下载 git 安装包，然后进行安装。 git bash 是一个命令行工具，用来操作和仓库有关的行为。 SSH 连接远程库 当前前提是需要拥有 github 的账号 注册github账户具体步骤很简单，不会可百度 创建 github 项目新建一个项目，然后仓库的名字必须是 xxx.github.io， 这也是之后访问的 URL。 到项目的设置里，去测试一下。 点击 setting，拉到下面有个 github pages， 单击 choose a theme选择主题。选择好以后，返回，然后点击xxx.github.io链接，就能看到博客页面了。 SSH授权通过 SSH 从本地同步连接到 githun 服务器。 打开git bash， 输入 ssh-keygen -t rsa，回车3下 这样就会在 C 盘用户目录下的.ssh目录下生成 id_rsa 和 id_rsa.pub两个文件。 前者是私钥，后者是公钥。 私钥，证明自己身份。 公钥，是给出去的。 用 txt 方式打开公钥id_rsa.pub，复制全部内容，添加到 Github 上。 这样本地的密钥id_rsa和 Github 上的公钥 id_rsa.pub进行配对。 在 Github 上，进入自己的 Setting 然后点击左侧的 SSH and GPG keys，然后添加一个 New SSH key，将公钥内容复制进去保存。 最后打开 git bash 输入 ssh -T git@github.com 进行授权测试。 若返回“hi xxxx You’ve successfullly….” 说明是授权成功的。 github desktop但是现在有更好的方式，不用使用这种传统使用命令行的方式了。就是下载 github的客户端版本,github desktop。 到 hexo 中执行博客提交命令时，一般会验证 SSH。现在有了这个只要一次登录就行了。 tortoisegit也是可视化操作 github 命令的。但是没有 desktop 现代 安装 Nodenode 安装，直接去官网下载一个。安装好之后，打开 Cmd 命令行，输入 node -v 检查下是否成功。 安装 Hexo 和初始化安装 Hexo 脚手架npm i -g hexo-cli，作为脚手架工具，相比之后会经常用到，所以安装到全局。 初始化博客本地目录 这里有个坑，之前创建的 github 项目，仅仅是作为特殊的博客载体。无需 clone 到本地。 我们会在本地写文章，然后本地启动 hexo 服务器查看静态页是怎样的，最后通过配置文件去指定上面的仓库URL，并获取权限。然后通过 hexo 一键部署到上面。 123hexo init xxx // 新建一个目录，作为 hexo 管理的博客项目。cd xxx // 进入这个目录npm i // 安装必要的依赖 Hexo 项目目录12345678├── _config.yml 配置文件├── package.json 依赖配置文件├── scaffolds 模板文件，每次新建 md 文章，都会去应用。默认就3个post等├── source 用户资源目录| ├── _drafts| └── _posts 文章所在地└── themes 主题选定。下载或者clone的主题包放这里。├── public 最后经过 Hexo 解析，被部署到 github 分支上的目录 开始 hello world基本配置不不管网站的内容，先从基本的网站配置开始。 配置文件，_config.yml。大部分的功能实现，都是基于这个配置 下面列出几个模块的配置项 网站 Site12345678# Sitetitle: ErrorJE's Blogsubtitle: ErrorJE 学习记录分享 (主要用于SEO)description: ErrorJE 前端技术keywords: ErrorJE 前端 架构师 全栈author: ErrorJElanguage: zhtimezone:（时区的名字） 网址 URL1基本没用。若博客放在子目录的，就需要指定下目录 目录 Directory1暂时不修改。主要是一些资源存放的目录设定 文章 Writing123456789101112131415new_post_name: :title.md # 新文章的文件名 # 可以使用 :year-:month-:day-:title.md 的格式，更方便管理default_layout: post # 默认布局titlecase: false # 转换 titleexternal_link: true # 新标签页中打开链接filename_case: 0render_drafts: falsepost_asset_folder: false # true时，每个文章顺带一个同名放资源的文件夹relative_link: false # 将链接改为根目录的相对地址future: true # 显示未来的文章highlight: # 代码块设置 enable: true line_number: true auto_detect: false tab_replace: 类和标签 Category &amp; Tag 在文章的头部信息中去配置不同的分类和标签 123456categories:- 前端- 工具tags:- 工具教程- 踩坑经验 日期/时间格式 Date / Time format 使用 moment.js 来解析时间 12date_format: YYYY-MM-DDtime_format: HH:mm:ss 分页 Pagination12per_page: 10 # 每页文章量（0位关闭分页功能）pagination_dir: page # 分页目录 扩展 Extensions 主题和部署地址123456theme: landscape # 当前主题名称deploy: # 部署部分 type: git # 使用 git 方式 repo: https://github.com/ErrorJe/ErrorJE.github.io # 承载博客的仓库地址 branch: [branch] # 分支名称。不写的话默认是 master 主分支 message: [message] # 非必需 基本命令初始化博客目录hexo init xxxx，新建一个名为 xxxx 的目录作为博客项目目录 新建文章hexo new 布局(默认 post) xxx，新建后的文章名为 xxx.md 若文件名有空格，则用引号包裹起来。 布局的区别 默认有3种，仅仅是写了基础信息的模板而已。在 scaffolds目录下 post 直接可以发布的文章 page draft，草稿。后期需要 publish 才可以部署 生成静态文件hexo g，还有两种选择 hexo g - d， 生成文件后立即部署网站 hexo g -w，监视文件变动 生成草稿 该步骤非必需 hexo publish 布局 文件名 启动本地服务测试 必须先安装依赖， npm i --S hexo-server。之后修改文章会自动更新服务。 hexo server，这是启动本地服务，可以看下效果。还有3个选项 hexo s -p xxxx， 重新设定端口号 hexo s -s 只使用静态文件 hexo s -l，启动日志记录，使用覆盖记录格式 部署网站hexo d一键部署。 如果不是用hexo-cli的话，这一步还需要安装 npm i -S hexo-deployer-git，用于发布博客到 git 的 Npm 包。 若报错没有找到 git ，也是因为没有安装这个依赖。 执行这个命令后，会让你登录 github 清除缓存和静态文件hexo clean，有时候更换主题没有变化，就需要清理缓存文件 db.json 和静态文件 public 开始写作实际写作时的步骤 hexo new post xxxx创建有基本信息填充的md文件 复制自己写好的 md 内容，然后根据需要修改头部文章基本信息 hexo g -d生成静态文件后直接部署 也可以本地调试 hexo g生成静态文件 hexo server本地测试 hexo d发布部署 更换主题的话可能还需要执行 hexo clean来清除缓存 创建文章文件hexo new 布局(默认 post) xxx，会在 .md 头部增加文章基本信息。 该文件会出现在 source/_posts，平时写作也就关心这个文件夹就行了。 文章的变量信息 Front-matter这是显示在每篇文章最上面，使用分割线区别文章内容，以表示文章基本信息的变量 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 资源文件在根目录下的 source 中，除了放文章，还可以把其他静态资源放进来。 但是注意，最大是300M。比如创建一个图片目录images，像下面一样使用。 虽然现在还没有显示，但是最后部署后，就是能访问到 当然也可以在配置文件中去设置，每次新建文件的时候，一起把同名的静态资源目录也生成。最后就能使用下面这样的方式，让网页和md文件都能看到图片。 1&#123;% asset_img example.jpg This is an example image %&#125; 其他自定义配置绑定域名 买个域名 去解析一下域名的 xxx.github.io，类型选择cname githun的仓库设置，去custom domain填入这个域名 若本地没有用的话，去 source目录新建CNAME文件，没有后缀，内容写域名 选择主题基本上一个博客，就是基于一个主题的。这里推荐 beantech。 切换主题下面3个步骤就可以搭建主题博客。 先找到这个主题的 github 地址 然后 clone 到博客项目的 theme 目录下 去博客根目录下， 配置 _config.yml，去extensions中找 theme 配置该主题名 主题初始化上面是在原有博客项目的基础上，去切换主题。 下面这种方式是，先有主题，然后再去写博客。 123git clone https://github.com/YenYuHsuan/hexo-theme-beantech.git ./hexo-beantechcd hexo-beantechnpm install 然后自定义配置文件等等。 推荐主题 NexThttps://theme-next.iissnan.com/getting-started.html 有中文文档，也是目前 star 最多的主题。 利用 Github 搭建图床在自己的博客git上创建一个个 issues，然后直接把图片拉进去就完事了。 然后找到该图片的 URL 地址，最后在自己的博客里用]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
